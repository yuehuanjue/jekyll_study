<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
   <title>tiankonguse blog</title>
   <link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://localhost:4000" rel="alternate" type="text/html" />
   <updated>2016-10-14T13:56:41+08:00</updated>
   <id>http://localhost:4000</id>
   <author>
     <name></name>
     <email></email>
   </author>
   
    
   <entry>
     <title>io模型</title>
     <link href="http://localhost:4000/blog/2016/09/26/io-style.html"/>
     <updated>2016-09-26T22:08:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/09/26/io-style</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;io模型是网络编程的基础知识.&lt;br /&gt;
最近准备设计一个适合自己项目的网络框架, 所以先回顾一下这些基础的网络知识点.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;这篇文章大部分内容摘自《Unix 网络编程》， 推荐想深入学习学习网络的人读一下这本书。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;io&quot;&gt;IO模型&lt;/h2&gt;

&lt;p&gt;linux下的IO模型有五种形式, 如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞式IO&lt;/li&gt;
  &lt;li&gt;非阻塞式IO&lt;/li&gt;
  &lt;li&gt;IO复用(select, poll, epoll)&lt;/li&gt;
  &lt;li&gt;信号驱动式IO (SIGIO)&lt;/li&gt;
  &lt;li&gt;异步IO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们先介绍一下上面提到的五种模型.&lt;/p&gt;

&lt;h3 id=&quot;io-1&quot;&gt;阻塞式IO&lt;/h3&gt;

&lt;p&gt;最流行的IO模型就是阻塞式IO模型.&lt;br /&gt;
这里需要阻塞两个阶段: 1. 等待数据报准备好 2. 等待内核数据复制到用户空间.&lt;/p&gt;

&lt;h3 id=&quot;io-2&quot;&gt;非阻塞式IO&lt;/h3&gt;

&lt;p&gt;进程把一个套接字设置成非阻塞是在通知内核:当所请求的IO操作非得把进程投入睡眠才能完成时, 不要把进程投入睡眠, 而是返回一个错误.&lt;br /&gt;
这种模型需要用户不断的轮循查询某个操作是否就绪, 往往很消耗CPU, 很少使用.&lt;/p&gt;

&lt;h3 id=&quot;io-3&quot;&gt;IO复用模型&lt;/h3&gt;

&lt;p&gt;我们使用select, poll或者 epoll阻塞在这些系统调用上, 而不是阻塞在真正的IO系统调用上.&lt;br /&gt;
好处是我们同一时间可以等待多个IO操作, 缺点是内核数据复制到用户空间时我们还需要等待.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;信号驱动式模型&lt;/h3&gt;

&lt;p&gt;我们设置一个信号和回调函数, 然后主循环可以继续执行做其他事.&lt;br /&gt;
当信号到达时, 需要等待数据从内核态复制到用户态.&lt;/p&gt;

&lt;h3 id=&quot;io-4&quot;&gt;异步IO模型&lt;/h3&gt;

&lt;p&gt;前面几种模型都在内核态到用户态传数据时存在等待, 而异步不需要等待.&lt;/p&gt;

&lt;h2 id=&quot;io-5&quot;&gt;IO模型总结&lt;/h2&gt;

&lt;p&gt;上面几种模型总结一下就是阻塞与非阻塞, 同步与异步, 可以参考下面的矩阵图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3210682953.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-6&quot;&gt;同步阻塞 IO&lt;/h3&gt;

&lt;p&gt;在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。&lt;br /&gt;
意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。&lt;br /&gt;
调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3194458355.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-7&quot;&gt;同步非阻塞 IO&lt;/h3&gt;

&lt;p&gt;非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。&lt;br /&gt;
这个方法会引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 read 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/4263470180.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-8&quot;&gt;异步阻塞 I/O&lt;/h3&gt;

&lt;p&gt;在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 select 系统调用来确定一个 I/O 描述符何时有操作。&lt;br /&gt;
使 select 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3896270965.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-9&quot;&gt;异步非阻塞 I/O&lt;/h3&gt;

&lt;p&gt;异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。&lt;br /&gt;
读请求会立即返回，说明 read 请求已经成功发起了。&lt;br /&gt;
在后台完成读操作时，应用程序然后会执行其他处理操作。&lt;br /&gt;
当 read 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2556479763.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;io-10&quot;&gt;IO模型的实现&lt;/h2&gt;

&lt;h3 id=&quot;select-&quot;&gt;select 实现&lt;/h3&gt;

&lt;p&gt;select 的调用过程大概如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3158094598.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用copy_from_user从用户空间拷贝fd_set到内核空间&lt;/li&gt;
  &lt;li&gt;注册回调函数__pollwait&lt;/li&gt;
  &lt;li&gt;遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）&lt;/li&gt;
  &lt;li&gt;以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。&lt;/li&gt;
  &lt;li&gt;__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列&lt;br /&gt;
对于tcp_poll来说，其等待队列是sk-&amp;gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。&lt;br /&gt;
在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。&lt;/li&gt;
  &lt;li&gt;poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。&lt;/li&gt;
  &lt;li&gt;如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。&lt;br /&gt;
当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。&lt;br /&gt;
如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。&lt;/li&gt;
  &lt;li&gt;把fd_set从内核空间拷贝到用户空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;poll&quot;&gt;poll实现&lt;/h3&gt;

&lt;p&gt;poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。&lt;br /&gt;
poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。&lt;/p&gt;

&lt;h3 id=&quot;epoll&quot;&gt;epoll实现&lt;/h3&gt;

&lt;p&gt;epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。&lt;br /&gt;
那epoll都是怎么解决的呢？&lt;/p&gt;

&lt;p&gt;在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。&lt;br /&gt;
而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。&lt;/p&gt;

&lt;p&gt;对于第一个缺点，epoll的解决方案在epoll_ctl函数中。&lt;br /&gt;
每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。&lt;br /&gt;
epoll保证了每个fd在整个过程中只会拷贝一次。&lt;/p&gt;

&lt;p&gt;对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数&lt;br /&gt;
当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。&lt;br /&gt;
epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。&lt;/p&gt;

&lt;p&gt;对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048&lt;br /&gt;
举个例子,在1GB内存的机器上大约是10万左右，具体数目可以&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /proc/sys/fs/file-max&lt;/code&gt;察看,一般来说这个数目和系统内存关系很大。&lt;/p&gt;

&lt;p&gt;epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：&lt;br /&gt;
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。&lt;br /&gt;
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;br /&gt;
ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。&lt;br /&gt;
epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。&lt;/p&gt;

&lt;h3 id=&quot;io-11&quot;&gt;异步 IO&lt;/h3&gt;

&lt;p&gt;Linux 异步 I/O 是 Linux 内核中提供的一个相当新的功能。&lt;br /&gt;
AIO 背后的基本思想是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。&lt;/p&gt;

&lt;p&gt;在异步非阻塞 I/O 中，我们可以同时发起多个传输操作。&lt;br /&gt;
这需要每个传输操作都有惟一的上下文，这样我们才能在它们完成时区分到底是哪个传输操作完成了。&lt;br /&gt;
在 AIO 中，这是一个 aiocb（AIO I/O Control Block）结构。&lt;br /&gt;
这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。&lt;br /&gt;
在产生 I/O （称为完成）通知时，aiocb 结构就被用来惟一标识所完成的 I/O 操作。&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>程序后台运行</title>
     <link href="http://localhost:4000/blog/2016/09/21/bg-run.html"/>
     <updated>2016-09-21T22:35:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/09/21/bg-run</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;经常会遇到这样一个问题, ssh登陆远程服务器, 运行一些程序.  后来退出时没跑完的程序也退出了.&lt;br /&gt;
即使我们加上&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 命令, 没跑完的程序依旧退出. &lt;br /&gt;
这篇文章就记录我们该如何让程序后台运行, 我们ssh退出的时候程序不退出.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原因&lt;/h2&gt;

&lt;p&gt;我们ssh登陆后, 运行的程序都是当前登陆会话的子进程.&lt;br /&gt;
会话关闭后, 子进程都被关闭了.&lt;br /&gt;
所以解决方案就是让后台运行的进程不是当前会话的子进程.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;启动时转后台&lt;/h2&gt;

&lt;p&gt;###　nohup&lt;/p&gt;

&lt;p&gt;nohup　是我最常用的手法． 
nohup  的作用就是忽略&lt;code class=&quot;highlighter-rouge&quot;&gt;hangups&lt;/code&gt;信号. &lt;br /&gt;
使用简单, 直接放在命令前面即可.&lt;br /&gt;
默认标准输出和标准错误缺省会被重定向到 nohup.out 文件中。&lt;br /&gt;
一般我们可在结尾加上&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;来将命令同时放入后台运行，也可用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;filename 2&amp;gt;&amp;amp;1&lt;/code&gt;来更改缺省的重定向文件名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nohup - run a command immune to hangups, with output to a non-tty
nohup myapp --start &amp;gt; ../log/some.log  2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;setsid&quot;&gt;setsid&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setsid&lt;/code&gt; 的功能是创建一个新会话, 也能满足我们的要求.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# setsid - run a program in a new session
setsid myapp --start &amp;gt; ../log/some.log  2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;shell&quot;&gt;shell小技巧&lt;/h3&gt;

&lt;p&gt;我们知道，将一个或多个命名包含在&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。&lt;/p&gt;

&lt;p&gt;当我们将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;也放入&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。&lt;br /&gt;
让我们来看看为什么这样就能躲过 HUP 信号的影响吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(myapp --start &amp;gt; ../log/some.log  2&amp;gt;&amp;amp;1 &amp;amp;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;运行中转后台&lt;/h2&gt;

&lt;p&gt;有时候我们的任务已经在运行了. 现在我们需要关闭会话, 但是不想停止任务.&lt;br /&gt;
这个时候就需要这个小节的知识点了.&lt;/p&gt;

&lt;h3 id=&quot;disown&quot;&gt;disown处理任务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;disown [-ar] [-h] [jobspec ...]
    Without options, each jobspec is removed from the table of active jobs.    
    If jobspec is not present, and neither -a nor -r is supplied,  the  shell’s notion  of the current job is used.  
    If the -h option is given, each jobspec is not removed from the table, but is marked so that SIGHUP is not sent to the job if the shell receives a SIGHUP.  
    If no jobspec is present, and neither the -a nor the -r option is supplied, the current job is used.  
    If no  jobspec  is  supplied,  the  -a option means to remove or mark all jobs; 
    the -r option without a jobspec argument restricts operation to running jobs.  
    The return value is 0 unless a jobspec does not specify a valid job.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，我们可以用如下方式来达成我们的目的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;disown -h jobspec&lt;/code&gt;来使某个作业忽略HUP信号。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;disown -ah&lt;/code&gt; 来使所有的作业都忽略HUP信号。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;disown -rh&lt;/code&gt; 来使正在运行的作业忽略HUP信号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -ef&lt;/code&gt;查找到它。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;正在运行中的任务&lt;/h3&gt;

&lt;p&gt;可以参考我14年的一篇文章&lt;a href=&quot;http://tiankonguse.com/record/record.php?id=592&quot;&gt;ubuntu 前台程序和后台程序&lt;/a&gt;.&lt;br /&gt;
我们可以把任务转为后台任务, 然后就可以再使用 disown 来转化为后台程序了.&lt;/p&gt;

&lt;h3 id=&quot;screen&quot;&gt;screen&lt;/h3&gt;

&lt;p&gt;我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？&lt;/p&gt;

&lt;p&gt;此时最方便的方法就是 screen 了。&lt;br /&gt;
screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME
    screen - screen manager with VT100/ANSI terminal emulation

SYNOPSIS
    screen [ -options ] [ cmd [ args ] ]
    screen -r [[pid.]tty[.host]]
    screen -r sessionowner/[[pid.]tty[.host]]

DESCRIPTION
    Screen  is  a  full-screen  window manager that multiplexes a physical
    terminal between several  processes  (typically  interactive  shells).
    Each  virtual  terminal provides the functions of a DEC VT100 terminal
    and, in addition, several control functions from the  ISO  6429  (ECMA
    48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
    support for multiple character sets).  There is a  scrollback  history
    buffer  for  each virtual terminal and a copy-and-paste mechanism that
    allows moving text regions between windows.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 screen 很方便，有以下几个常用选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;screen -dmS session name&lt;/code&gt;来建立一个处于断开模式下的会话（并指定其会话名）。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;screen -list &lt;/code&gt;来列出所有会话。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;screen -r session name&lt;/code&gt;来重新连接指定会话。&lt;/li&gt;
  &lt;li&gt;用快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL-a d &lt;/code&gt;来暂时断开当前会话。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们用&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;setsid&lt;/code&gt;了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup/setsid&lt;/code&gt; 无疑是临时需要时最方便的方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;disown &lt;/code&gt;能帮助我们来事后补救当前已经在运行了的作业，而&lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt; 则是在大批量操作时不二的选择了。&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>内存屏障</title>
     <link href="http://localhost:4000/blog/2016/09/09/memory-barriers.html"/>
     <updated>2016-09-09T22:45:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/09/09/memory-barriers</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;这篇文章简单的记录内存屏障的知识点.&lt;br /&gt;
大部分摘自《Linux内核文档 – Documentation/memory-barriers.txt》。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存屏障作用&lt;/h2&gt;

&lt;p&gt;内存屏障是为应付内存访问操作的乱序执行而生的. &lt;br /&gt;
那么, 内存访问为什么会乱序呢?&lt;/p&gt;

&lt;p&gt;这里先简要介绍一下:&lt;/p&gt;

&lt;p&gt;现在的CPU一般采用流水线来执行指令. &lt;br /&gt;
一个指令的执行被分成: 取指, 译码, 访存, 执行,写回, 等若干个阶段.&lt;/p&gt;

&lt;p&gt;指令流水线并不是串行化的, 并不会因为一个耗时很长的指令在”执行”阶段呆很长时间, 而导致后续的指令都卡在”执行”之前的阶段上.&lt;/p&gt;

&lt;p&gt;相反, 流水线中的多个指令是可以同时处于一个阶段的, 只要CPU内部相应的处理部件未被占满. &lt;br /&gt;
比如说CPU有一个加法器和一个除法器, 那么一条加法指令和一条除法指令就可能同时处于”执行”阶段, 而两条加法指令在”执行”阶段就只能串行工作.&lt;/p&gt;

&lt;p&gt;这样一来, 乱序可能就产生了. 比如一条加法指令出现在一条除法指令的后面, 但是由于除法的执行时间很长, 在它执行完之前, 加法可能先执行完了. &lt;br /&gt;
再比如两条访存指令, 可能由于第二条指令命中了cache(或其他原因)而导致它先于第一条指令完成.&lt;/p&gt;

&lt;p&gt;一般情况下, 指令乱序并不是CPU在执行指令之前刻意去调整顺序. &lt;br /&gt;
CPU总是顺序的去内存里面取指令, 然后将其顺序的放入指令流水线. &lt;br /&gt;
但是指令执行时的各种条件, 指令与指令之间的相互影响, 可能导致顺序放入流水线的指令, 最终乱序执行完成. &lt;br /&gt;
这就是所谓的”顺序流入, 乱序流出”.&lt;/p&gt;

&lt;p&gt;指令流水线除了在资源不足的情况下会卡住之外(如前所述的一个加法器应付两条加法指令), 指令之间的相关性才是导致流水线阻塞的主要原因.&lt;/p&gt;

&lt;p&gt;下文中也会多次提到, CPU的乱序执行并不是任意的乱序, 而必须保证上下文依赖逻辑的正确性. &lt;br /&gt;
比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;a++; b=f(a);&lt;/code&gt; 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;b=f(a)&lt;/code&gt;这条指令依赖于第一条指令&lt;code class=&quot;highlighter-rouge&quot;&gt;a++&lt;/code&gt;的执行结果, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;b=f(a)&lt;/code&gt;将在”执行”阶段之前被阻塞, 直到&lt;code class=&quot;highlighter-rouge&quot;&gt;a++&lt;/code&gt;的执行结果被生成出来.&lt;/p&gt;

&lt;p&gt;如果两条像这样有依赖关系的指令挨得很近, 后一条指令必定会因为等待前一条执行的结果, 而在流水线中阻塞很久. &lt;br /&gt;
而编译器的乱序, 作为编译优化的一种手段, 则试图通过指令重排将这样的两条指令拉开距离, 以至于后一条指令执行的时候前一条指令结果已经得到了, 那么也就不再需要阻塞等待了.&lt;/p&gt;

&lt;p&gt;相比于CPU的乱序, 编译器的乱序才是真正对指令顺序做了调整. &lt;br /&gt;
但是编译器的乱序也必须保证程序上下文的依赖逻辑.&lt;/p&gt;

&lt;p&gt;由于指令执行存在这样的乱序, 那么自然, 由指令执行而引发的内存访问势必也可能乱序.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;内存访问抽象模型.&lt;/h2&gt;

&lt;p&gt;多核CPU架构大概如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              :                :
              :                :
  +-------+   :   +--------+   :   +-------+
  |       |   :   |        |   :   |       |
  |       |   :   |        |   :   |       |
  | CPU 1 |&amp;lt;-----&amp;gt;|  内存  |&amp;lt;-----&amp;gt;| CPU 2 |
  |       |   :   |        |   :   |       |
  |       |   :   |        |   :   |       |
  +-------+   :   +--------+   :   +-------+
      ^       :       ^        :       ^
      |       :       |        :       |
      |       :       |        :       |
      |       :       v        :       |
      |       :   +--------+   :       |
      |       :   |        |   :       |
      |       :   |        |   :       |
      +----------&amp;gt;|  设备  |&amp;lt;----------+
              :   |        |   :
              :   |        |   :
              :   +--------+   :
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设每个CPU都分别运行着一个会触发内存访问操作的程序. &lt;br /&gt;
对于这样一个CPU, 其内存访问顺序是非常松散的, 在保证程序上下文逻辑关系的前提下, CPU可以按它所喜欢的顺序来执行内存操作. &lt;br /&gt;
类似的, 编译器也可以将它输出的指令安排成任何它喜欢的顺序, 只要保证不影响程序表面的执行逻辑.&lt;/p&gt;

&lt;p&gt;在上面的图示中, 一个CPU执行内存操作所产生的影响, 一直要到该操作穿越该CPU与系统中其他部分的界面(见图中的虚线)之后, 才能被其他部分所感知.&lt;/p&gt;

&lt;p&gt;举例来说, 考虑如下的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ A == 1; B == 2 }
A = 3;          x = A;
B = 4;          y = B;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这一组访问指令在内存系统(见上图的中间部分)上生效的顺序, 可以有&lt;code class=&quot;highlighter-rouge&quot;&gt;4!=24&lt;/code&gt;种不同的组合:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STORE A=3,   STORE B=4,     x=LOAD A-&amp;gt;3,   y=LOAD B-&amp;gt;4
STORE A=3,   STORE B=4,     y=LOAD B-&amp;gt;4,   x=LOAD A-&amp;gt;3
STORE A=3,   x=LOAD A-&amp;gt;3,   STORE B=4,     y=LOAD B-&amp;gt;4
STORE A=3,   x=LOAD A-&amp;gt;3,   y=LOAD B-&amp;gt;2,   STORE B=4
STORE A=3,   y=LOAD B-&amp;gt;2,   STORE B=4,     x=LOAD A-&amp;gt;3
STORE A=3,   y=LOAD B-&amp;gt;2,   x=LOAD A-&amp;gt;3,   STORE B=4
STORE B=4,   STORE A=3,     x=LOAD A-&amp;gt;3,   y=LOAD B-&amp;gt;4
STORE B=4, ...
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后这就产生四种不同组合的结果值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x == 1, y == 2
x == 1, y == 4
x == 3, y == 2
x == 3, y == 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;甚至于, 一个CPU在内存系统上提交的STORE操作还可能不会以相同的顺序被其他CPU所执行的LOAD操作所感知.&lt;/p&gt;

&lt;p&gt;进一步举例说明, 考虑如下的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ A == 1, B == 2, C == 3, P == &amp;amp;A, Q == &amp;amp;C }
B = 4;          Q = P;
P = &amp;amp;B          D = *Q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有一处明显的数据依赖, 因为在CPU2上, LOAD到D里面的值依赖于从P获取到的地址. 在
操作序列的最后, 下面的几种结果都是有可能出现的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(Q == &amp;amp;A) 且 (D == 1)
(Q == &amp;amp;B) 且 (D == 2)
(Q == &amp;amp;B) 且 (D == 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意, CPU2决不会将C的值LOAD到D, 因为CPU保证在将P的值装载到Q之后才会执行对*Q的LOAD操作(译注: 因为存在数据依赖).&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;操作设备&lt;/h3&gt;

&lt;p&gt;对于一些设备, 其控制寄存器被映射到一组内存地址集合上, 而这些控制寄存器被访问的顺序是至关重要的. &lt;br /&gt;
假设, 一个以太网卡拥有一些内部寄存器, 通过一个地址端口寄存器(A)和一个数据端口寄存器(D)来访问它们. &lt;br /&gt;
要读取编号为5的内部寄存器, 可能使用如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = 5;
x = *D;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这可能会表现为以下两个序列之一(译注: 因为从程序表面看, A和D是不存在依赖的):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STORE *A = 5, x = LOAD *D
x = LOAD *D, STORE *A = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中的第二种几乎肯定会导致错误, 因为它在读取寄存器之后才设置寄存器的编号.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;保证&lt;/h3&gt;

&lt;p&gt;对于一个CPU, 它最低限度会提供如下的保证:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于一个CPU, 在它上面出现的有上下文依赖关系的内存访问将被按顺序执行. &lt;br /&gt;
这意味着:&lt;code class=&quot;highlighter-rouge&quot;&gt;Q = P; D = *Q;&lt;/code&gt; CPU会顺序执行以下访存:&lt;code class=&quot;highlighter-rouge&quot;&gt;Q = LOAD P, D = LOAD *Q&lt;/code&gt;, 并且总是按这样的顺序&lt;/li&gt;
  &lt;li&gt;对于一个CPU, 重叠的LOAD和STORE操作将被按顺序执行. &lt;br /&gt;
这意味着:&lt;code class=&quot;highlighter-rouge&quot;&gt;a = *X; *X = b;&lt;/code&gt;CPU只会按以下顺序执行访存:&lt;code class=&quot;highlighter-rouge&quot;&gt;a = LOAD *X, STORE *X = b&lt;/code&gt;
同样, 对于:&lt;code class=&quot;highlighter-rouge&quot;&gt;*X = c; d = *X;&lt;/code&gt; CPU只会按以下顺序执行访存:&lt;code class=&quot;highlighter-rouge&quot;&gt;STORE *X = c, d = LOAD *X&lt;/code&gt;&lt;br /&gt;
(如果LOAD和STORE的目标指向同一块内存地址, 则认为是重叠).&lt;br /&gt;
还有一些事情是必须被假定或者必须不被假定的&lt;/li&gt;
  &lt;li&gt;必须不能假定无关的LOAD和STORE会按给定的顺序被执行. &lt;br /&gt;
这意味着:&lt;code class=&quot;highlighter-rouge&quot;&gt;  X = *A; Y = *B; *D = Z;&lt;/code&gt;可能会得到如下几种执行序列之一:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
X = LOAD *A,  Y = LOAD *B,  STORE *D = Z
X = LOAD *A,  STORE *D = Z, Y = LOAD *B
Y = LOAD *B,  X = LOAD *A,  STORE *D = Z
Y = LOAD *B,  STORE *D = Z, X = LOAD *A
STORE *D = Z, X = LOAD *A,  Y = LOAD *B
STORE *D = Z, Y = LOAD *B,  X = LOAD *A
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;必须假定重叠内存访问可能被合并或丢弃. &lt;br /&gt;
这意味着:&lt;code class=&quot;highlighter-rouge&quot;&gt;X = *A; Y = *(A + 4);&lt;/code&gt; 可能会得到如下几种执行序列之一:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
X = LOAD *A; Y = LOAD *(A + 4);
Y = LOAD *(A + 4); X = LOAD *A;
{X, Y} = LOAD {*A, *(A + 4) };
&lt;/code&gt;
同样, 对于:&lt;code class=&quot;highlighter-rouge&quot;&gt;*A = X; Y = *A;&lt;/code&gt;可能会得到如下几种执行序列之一:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
STORE *A = X; Y = LOAD *A;
STORE *A = Y = X;
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;什么是内存屏障&lt;/h2&gt;

&lt;p&gt;正如上面所说, 无关的内存操作会被按随机顺序有效的得到执行, 但是在CPU与CPU交互时或CPU与IO设备交互时, 这可能会成为问题.&lt;br /&gt;
我们需要一些手段来干预编译器和CPU, 使其限制指令顺序.&lt;/p&gt;

&lt;p&gt;内存屏障就是这样的干预手段. &lt;br /&gt;
他们能保证处于内存屏障两边的内存操作满足部分有序. 
(译注: 这里”部分有序”的意思是, 内存屏障之前的操作都会先于屏障之后的操作, 但是如果几个操作出现在屏障的同一边, 则不保证它们的顺序. 这一点下文将多次提到.)&lt;/p&gt;

&lt;p&gt;这样的强制措施是非常重要的, 因为系统中的CPU和其他设备可以使用各种各样的策略来提高性能, 包括对内存操作的乱序, 延迟和合并执行; 预取; 投机性的分支预测和各种缓存. &lt;br /&gt;
内存屏障用于禁用或抑制这些策略, 使代码能够清楚的控制多个CPU和/或设备的交互.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;各式各样的内存屏障&lt;/h3&gt;

&lt;p&gt;内存屏障有四种基本类型:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写(STORE)内存屏障.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;写内存屏障提供这样的保证: 所有出现在屏障之前的STORE操作都将先于所有出现在屏障之后的STORE操作被系统中的其他组件所感知.&lt;br /&gt;
写屏障仅保证针对STORE操作的部分有序; 不要求对LOAD操作产生影响.&lt;/p&gt;

&lt;p&gt;随着时间的推移, 一个CPU提交的STORE操作序列将被存储系统所感知. &lt;br /&gt;
所有在写屏障之前的STORE操作将先于所有在写屏障之后的STORE操作出现在被感知的序列中.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意, 写屏障一般需要与读屏障或数据依赖屏障配对使用; 参阅”SMP内存屏障配对”章节. &lt;br /&gt;
(译注: 因为写屏障只保证自己提交的顺序, 而无法干预其他代码读内存的顺序. 所以配对使用很重要. 其他类型的屏障亦是同理.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;数据依赖屏障.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据依赖屏障是读屏障的弱化版本. &lt;br /&gt;
假设有两个LOAD操作的场景, 其中第二个LOAD操作的结果依赖于第一个操作  (比如, 第一个LOAD获取地址, 而第二个LOAD使用该地址去取数据), 数据依赖屏障确保在第一个LOAD获取的地址被用于访问之前, 第二个LOAD的目标内存已经更新.&lt;br /&gt;
(译注: 因为第二个LOAD要使用第一个LOAD的结果来作为LOAD的目标, 这里存在着数据依赖. 由前面的”保证”章节可知, 第一个LOAD必定会在第二个LOAD之前执行, 不需要使用读屏障来保证顺序, 只需要使用数据依赖屏障来保证内存已刷新.)&lt;/p&gt;

&lt;p&gt;数据依赖屏障仅保证针对相互依赖的LOAD操作的部分有序; 不要求对STORE操作, 独立的LOAD操作, 或重叠的LOAD操作产生影响.&lt;/p&gt;

&lt;p&gt;正如(1)中所提到的, 在一个CPU看来, 系统中的其他CPU提交到内存系统的STORE操作序列在某一时刻可以被其感知到. &lt;br /&gt;
而在该CPU上触发的数据依赖屏障将保证, 对于在屏障之前发生的LOAD操作, 如果一个LOAD操作的目标被其他CPU的STORE操作所修改, 那么在屏障完成之时, 这个对应的STORE操作之前的所有STORE操作所产生的影响, 将被数据依赖屏障之后执行的LOAD操作所感知.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参阅”内存屏障举例”章节所描述的时序图.&lt;br /&gt;
注意, 对第一个LOAD的依赖的确是一个数据依赖而不是控制依赖. &lt;br /&gt;
而如果第二个LOAD的地址依赖于第一个LOAD, 但并不是通过实际加载的地址本身这样的依赖条件, 那么这就是控制依赖, 需要一个完整的读屏障或更强的屏障.&lt;/p&gt;

  &lt;p&gt;参阅”控制依赖”相关章节.&lt;br /&gt;
注意, 数据依赖屏障一般要跟写屏障配对使用; 参阅”SMP内存屏障的配对使用”章节.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;读(LOAD)内存屏障.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;读屏障包含数据依赖屏障的功能, 并且保证所有出现在屏障之前的LOAD操作都将先于所有出现在屏障之后的LOAD操作被系统中的其他组件所感知.&lt;br /&gt;
读屏障仅保证针对LOAD操作的部分有序; 不要求对STORE操作产生影响.&lt;br /&gt;
读内存屏障隐含了数据依赖屏障, 因此可以用于替代它们.&lt;/p&gt;

&lt;p&gt;注意, 读屏障一般要跟写屏障配对使用; 参阅”SMP内存屏障的配对使用”章节.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通用内存屏障&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通用内存屏障保证所有出现在屏障之前的LOAD和STORE操作都将先于所有出现在屏障之后的LOAD和STORE操作被系统中的其他组件所感知.&lt;br /&gt;
通用内存屏障是针对LOAD和STORE操作的部分有序.&lt;br /&gt;
通用内存屏障隐含了读屏障和写屏障, 因此可以用于替代它们.&lt;/p&gt;

&lt;p&gt;内存屏障还有两种隐式类型.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;LOCK操作.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它的作用相当于一个单向渗透屏障. 它保证所有出现在LOCK之后的内存操作都将在LOCK操作被系统中的其他组件所感知之后才能发生.&lt;br /&gt;
出现在LOCK之前的内存操作可能在LOCK完成之后才发生.&lt;br /&gt;
LOCK操作总是跟UNLOCK操作配对出现的.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;UNLOCK操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它的作用也相当于一个单向渗透屏障. 它保证所有出现在UNLOCK之前的内存操作都将在UNLOCK操作被系统中的其他组件所感知之前发生.&lt;br /&gt;
出现在UNLOCK之后的内存操作可能在UNLOCK完成之前就发生了.&lt;/p&gt;

&lt;p&gt;需要保证LOCK和UNLOCK操作严格按照相互影响的正确顺序出现.&lt;br /&gt;
(译注: LOCK和UNLOCK的这种单向屏障作用, 确保临界区内的访存操作不能跑到临界区外, 否则就起不到”保护”作用了.&lt;br /&gt;
使用LOCK和UNLOCK之后, 一般就不再需要其他内存屏障了(但是注意”MMIO写屏障”章节中所提到的例外).&lt;/p&gt;

&lt;p&gt;只有在存在多CPU交互或CPU与设备交互的情况下才可能需要用到内存屏障. &lt;br /&gt;
如果可以确保某段代码中不存在这样的交互, 那么这段代码就不需要使用内存屏障. &lt;br /&gt;
译注: CPU乱序执行指令, 同样会导致寄存器的存取顺序被打乱, 但是为什么不需要寄存器屏障呢? &lt;br /&gt;
就是因为寄存器是CPU私有的, 不存在跟其他CPU或设备的交互.&lt;/p&gt;

&lt;p&gt;注意, 对于前面提到的最低限度保证. 不同的体系结构可能提供更多的保证, 但是在特定体系结构的代码之外, 不能依赖于这些额外的保证.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;关于内存屏障, 不能假定什么?&lt;/h3&gt;

&lt;p&gt;Linux内核的内存屏障不保证下面这些事情:&lt;/p&gt;

&lt;p&gt;(*) 在内存屏障之前出现的内存访问不保证在内存屏障指令完成之前完成; &lt;br /&gt;
    内存屏障相当于在该CPU的访问队列中画一条线, 使得相关访存类型的请求不能相互跨越. 
    译注:用于实现内存屏障的指令, 其本身并不作为参考对象, 其两边的访存操作才被当作参考对象. &lt;br /&gt;
    所以屏障指令执行完成并不表示出现在屏障之前的访存操作已经完成. &lt;br /&gt;
    而如果屏障之后的某一个访存操作已经完成, 则屏障之前的所有访存操作必定都已经完成了.)&lt;/p&gt;

&lt;p&gt;(*) 在一个CPU上执行的内存屏障不保证会直接影响其他系统中的CPU或硬件设备. &lt;br /&gt;
    只会间接影响到第二个CPU感知第一个CPU产生访存效果的顺序, 不过请看下一点:&lt;/p&gt;

&lt;p&gt;(*) 不能保证一个CPU能够按顺序看到另一个CPU的访存效果, 即使另一个CPU使用了内存屏障, 除非这个CPU也使用了与之配对的内存屏障(参阅”SMP内存屏障的配对使用”章节).&lt;/p&gt;

&lt;p&gt;(*) 不保证一些与CPU相关的硬件不会乱序访存. &lt;br /&gt;
    CPU cache一致性机构会在CPU之间传播内存屏障所带来的间接影响, 但是可能不是按顺序的.&lt;/p&gt;

&lt;p&gt;更多关于总线主控DMA和一致性的问题请参阅:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Documentation/PCI/pci.txt&lt;/li&gt;
  &lt;li&gt;Documentation/PCI/PCI-DMA-mapping.txt&lt;/li&gt;
  &lt;li&gt;Documentation/DMA-API.txt&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;数据依赖屏障&lt;/h3&gt;

&lt;p&gt;数据依赖屏障的使用需求有点微妙, 并不总是很明显就能看出需要他们. &lt;br /&gt;
为了说明这一点, 考虑如下的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ A == 1, B == 2, C = 3, P == &amp;amp;A, Q == &amp;amp;C }
B = 4;
&amp;lt;写屏障&amp;gt;
P = &amp;amp;B
                Q = P;
                D = *Q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有明显的数据依赖, 在序列执行完之后, Q的值一定是&amp;amp;A和&amp;amp;B之一, 也就是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(Q == &amp;amp;A) 那么 (D == 1)
(Q == &amp;amp;B) 那么 (D == 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是CPU 2可能在看到P被更新之后, 才看到B被更新, 这就导致下面的情况:&lt;code class=&quot;highlighter-rouge&quot;&gt;Q == &amp;amp;B&lt;/code&gt; 且 &lt;code class=&quot;highlighter-rouge&quot;&gt;D == 2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;虽然这看起来似乎是一个一致性错误或逻辑关系错误, 但其实不是, 并且在一些真实的CPU中就能看到这样的行为(就比如DEC Alpha).&lt;/p&gt;

&lt;p&gt;为了解决这个问题, 必须在取地址和取数据之间插入一个数据依赖或更强的屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ A == 1, B == 2, C = 3, P == &amp;amp;A, Q == &amp;amp;C }
B = 4;
&amp;lt;写屏障&amp;gt;
P = &amp;amp;B
                Q = P;
                &amp;lt;数据依赖屏障&amp;gt;
                D = *Q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这将强制最终结果是前两种情况之一, 而避免出现第三种情况.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意, 这种非常违反直觉的情况最容易出现在cache分列的机器上, 
比如, 一个cache组处理偶数号的cache行, 另一个cache组处理奇数号的cache行. &lt;br /&gt;
P指针可能存储在奇数号的cache行中, 而B的值可能存储在偶数号的cache行中. &lt;br /&gt;
这样一来, 如果执行读操作的CPU的偶数号cache组非常繁忙, 而奇数号cache组空闲, 它就可能看到P已被更新成新值&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;B&lt;/code&gt;, 而B还是旧值2.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另一个可能需要数据依赖屏障的例子是, 从内存读取一个数值, 用于计算数组的访问偏移:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ M[0] == 1, M[1] == 2, M[3] = 3, P == 0, Q == 3 }
M[1] = 4;
&amp;lt;写屏障&amp;gt;
P = 1
                Q = P;
                &amp;lt;数据依赖屏障&amp;gt;
                        D = M[Q];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数据依赖屏障对于RCU非常重要, 举例来说. 参阅include/linux/rcupdate.h文件中的rcu_dereference()函数. &lt;br /&gt;
这个函数使得当前RCU指针指向的对象被替换成新的对象时, 不会发生新对象尚未初始化完成的情况.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译注: 更新RCU对象时, 一般步骤是: &lt;br /&gt;
1-为新对象分配空间; &lt;br /&gt;
2-初始化新对象; &lt;br /&gt;
3-调用rcu_dereference()函数, 将对象指针指到新的对象上, 这就意味着新的对象已生效. &lt;br /&gt;
这个过程中如果出现乱序访存, 可能导致对象指针的更新发生在新对象初始化完成之前.&lt;br /&gt;
也就是说, 新对象尚未初始化完成就已经生效了. 那么别的CPU就可能引用到一个尚未初始化完成的新对象, 从而出现错误.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更详尽的例子请参阅”Cache一致性”章节.&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;控制依赖&lt;/h3&gt;

&lt;p&gt;控制依赖需要使用一个完整的读内存屏障, 简单的数据依赖屏障不能使其正确工作. &lt;br /&gt;
考虑下面的代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q = &amp;amp;a;
if (p)
        q = &amp;amp;b;
&amp;lt;数据依赖屏障&amp;gt;
x = *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段代码可能达不到预期的效果, 因为这里其实并不是数据依赖, 而是控制依赖, CPU可能试图通过提前预测结果而对&lt;code class=&quot;highlighter-rouge&quot;&gt;if (p)&lt;/code&gt;进行短路.&lt;br /&gt;
在这样的情况下, 需要的是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q = &amp;amp;a;
if (p)
        q = &amp;amp;b;
&amp;lt;读屏障&amp;gt;
x = *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ a == 1, b == 2, p == 0}
a = 3;
b = 4;
&amp;lt;写屏障&amp;gt;
p = 1;
                q = &amp;amp;a;
                if (p)
                        q = &amp;amp;b;
                &amp;lt;数据依赖屏障&amp;gt;
                x = *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CPU 1上的写屏障是为了保证这样的逻辑: 如果p == 1, 那么必定有a == 3 &amp;amp;&amp;amp; b == 4.&lt;br /&gt;
但是到了CPU 2, 可能p的值已更新(==1), 而a和b的值未更新, 那么这时数据依赖屏障可以起作用, 确保&lt;code class=&quot;highlighter-rouge&quot;&gt;x = *q&lt;/code&gt;时a和b的值更新. &lt;br /&gt;
因为从代码逻辑上说, q跟a或b是有所依赖的, 数据依赖屏障能保证这些有依赖关系的值都已更新.&lt;/p&gt;

&lt;p&gt;然而, 换一个写法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
{ a == 1, b == 2, p == 0}
p = 1;
&amp;lt;写屏障&amp;gt;
a = 3;
b = 4;
                q = &amp;amp;a;
                if (p)
                        q = &amp;amp;b;
                &amp;lt;读屏障&amp;gt;
                x = *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CPU 1上的写屏障是为了保证这样的逻辑: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;a == 3 || b == 4&lt;/code&gt;, 那么必定有&lt;code class=&quot;highlighter-rouge&quot;&gt;p == 1&lt;/code&gt;.&lt;br /&gt;
但是到了CPU 2, 可能a或b的值已更新, 而p的值未更新. &lt;br /&gt;
那么这时使用数据依赖屏障就不能保证p的更新. &lt;br /&gt;
因为从代码逻辑上说, p跟任何人都没有依赖关系. 这时必须使用读屏障, 以确保&lt;code class=&quot;highlighter-rouge&quot;&gt;x = *q&lt;/code&gt;之前, p被更新.&lt;br /&gt;
原文中”短路”的意思就是, 由于p没有数据依赖关系, CPU可以早早获得它的值, 而不必考虑更新.&lt;/p&gt;

&lt;h3 id=&quot;smp&quot;&gt;SMP内存屏障的配对使用&lt;/h3&gt;

&lt;p&gt;在处理CPU与CPU的交互时, 对应类型的内存屏障总是应该配对使用. &lt;br /&gt;
缺乏适当配对的使用基本上可以肯定是错误的.&lt;/p&gt;

&lt;p&gt;一个写屏障总是与一个数据依赖屏障或读屏障相配对, 虽然通用屏障也可行. &lt;br /&gt;
类似的, 一个读屏障或数据依赖屏障也总是与一个写屏障相配对, 尽管一个通用屏障也同样可行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
a = 1;
&amp;lt;写屏障&amp;gt;
b = 2;          x = b;
                &amp;lt;读屏障&amp;gt;
                y = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2
=============== ===============
a = 1;
&amp;lt;写屏障&amp;gt;
b = &amp;amp;a;         x = b;
                &amp;lt;数据依赖屏障&amp;gt;
                y = *x;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上, 读屏障总是需要用在这些地方的, 尽管可以使用”弱”类型.&lt;/p&gt;

&lt;p&gt;注意, 在写屏障之前出现的STORE操作通常总是期望匹配读屏障或数据依赖屏障之后出现的LOAD操作, 反之亦然:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        CPU 1                       CPU 2
        ===============             ===============
        a = 1;       }----   ---&amp;gt;{  v = c
        b = 2;       }    \ /    {  w = d
        &amp;lt;写屏障&amp;gt;           \        &amp;lt;读屏障&amp;gt;
        c = 3;       }    / \    {  x = a;
        d = 4;       }----   ---&amp;gt;{  y = b;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;内存屏障举例&lt;/h3&gt;

&lt;p&gt;首先, 写屏障用作部分有序的STORE操作. &lt;br /&gt;
考虑如下的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1
=======================
STORE A = 1
STORE B = 2
STORE C = 3
&amp;lt;写屏障&amp;gt;
STORE D = 4
STORE E = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个操作序列会按顺序被提交到内存一致性系统, 而系统中的其他组件可能看到&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;A,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;B,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;的组合出现在&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;D,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STORE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;的组合之前, 而组合内部可能乱序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :
|       |       +------+
|       |------&amp;gt;| C=3  |     }     /\
|       |  :    +------+     }-----  \  -----&amp;gt; 操作被系统中的其他
|       |  :    | A=1  |     }        \/       组件所感知
|       |  :    +------+     }
| CPU 1 |  :    | B=2  |     }
|       |       +------+     }
|       |   wwwwwwwwwwwwwwww }   &amp;lt;--- 在这一时刻, 写屏障要求在它之
|       |       +------+     }        前出现的STORE操作都先于在它
|       |  :    | E=5  |     }        之后出现的STORE操作被提交
|       |  :    +------+     }
|       |------&amp;gt;| D=4  |     }
|       |       +------+
+-------+       :      :
                   |
                   | CPU 1发起的STORE操作被提交到内存系统的顺序
                   |
                   V
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其次, 数据依赖屏障用作部分有序的数据依赖LOAD操作. &lt;br /&gt;
考虑如下的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                        CPU 2
=======================      =======================
{ B = 7; X = 9; Y = 8; C = &amp;amp;Y }
STORE A = 1
STORE B = 2
&amp;lt;写屏障&amp;gt;
STORE C = &amp;amp;B                 LOAD X
STORE D = 4                  LOAD C (得到&amp;amp;B)
                             LOAD *C (读取B)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;没有干预的话, CPU 1的操作被CPU 2感知到的顺序是随机的, 尽管CPU 1执行了写屏障：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+  | CPU 2所看到的
|       |------&amp;gt;| B=2  |-----       ---&amp;gt;| Y-&amp;gt;8  |  | 更新序列
|       |  :    +------+     \          +-------+  |
| CPU 1 |  :    | A=1  |      \     ---&amp;gt;| C-&amp;gt;&amp;amp;Y |  V
|       |       +------+       |        +-------+
|       |   wwwwwwwwwwwwwwww   |        :       :
|       |       +------+       |        :       :
|       |  :    | C=&amp;amp;B |---    |        :       :       +-------+
|       |  :    +------+   \   |        +-------+       |       |
|       |------&amp;gt;| D=4  |    -----------&amp;gt;| C-&amp;gt;&amp;amp;B |------&amp;gt;|       |
|       |       +------+       |        +-------+       |       |
+-------+       :      :       |        :       :       |       |
                               |        :       :       |       |
                               |        :       :       | CPU 2 |
                               |        +-------+       |       |
    对B的取值显然不正确  ---&amp;gt;  |        | B-&amp;gt;7  |------&amp;gt;|       |
                               |        +-------+       |       |
                               |        :       :       |       |
                               |        +-------+       |       |
    对X的LOAD延误了B的  ---&amp;gt;    \       | X-&amp;gt;9  |------&amp;gt;|       |
    一致性更新                   \      +-------+       |       |
                                  -----&amp;gt;| B-&amp;gt;2  |       +-------+
                                        +-------+
                                        :       :
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的例子中, CPU 2看到的B的值是7, 尽管对*C(值应该是B)的LOAD发生在对C的LOAD之后.&lt;/p&gt;

&lt;p&gt;但是, 如果一个数据依赖屏障被放到CPU 2的LOAD C和LOAD *C(假设值是B)之间:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                        CPU 2
=======================      =======================
{ B = 7; X = 9; Y = 8; C = &amp;amp;Y }
STORE A = 1
STORE B = 2
&amp;lt;写屏障&amp;gt;
STORE C = &amp;amp;B                 LOAD X
STORE D = 4                  LOAD C (获得&amp;amp;B)
                             &amp;lt;数据依赖屏障&amp;gt;
                             LOAD *C (读取B)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么下面的情况将会发生:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&amp;gt;| B=2  |-----       ---&amp;gt;| Y-&amp;gt;8  |
|       |  :    +------+     \          +-------+
| CPU 1 |  :    | A=1  |      \     ---&amp;gt;| C-&amp;gt;&amp;amp;Y |
|       |       +------+       |        +-------+
|       |   wwwwwwwwwwwwwwww   |        :       :
|       |       +------+       |        :       :
|       |  :    | C=&amp;amp;B |---    |        :       :       +-------+
|       |  :    +------+   \   |        +-------+       |       |
|       |------&amp;gt;| D=4  |    -----------&amp;gt;| C-&amp;gt;&amp;amp;B |------&amp;gt;|       |
|       |       +------+       |        +-------+       |       |
+-------+       :      :       |        :       :       |       |
                               |        :       :       |       |
                               |        :       :       | CPU 2 |
                               |        +-------+       |       |
                               |        | X-&amp;gt;9  |------&amp;gt;|       |
                               |        +-------+       |       |
  确保STORE C之前的影响  ---&amp;gt;   \   ddddddddddddddddd   |       |
  都被后续的LOAD操作感           \      +-------+       |       |
  知到                            -----&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                                        +-------+       |       |
                                        :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第三, 读屏障用作部分有序的LOAD操作. 考虑如下事件序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                        CPU 2
=======================      =======================
{ A = 0, B = 9 }
STORE A=1
&amp;lt;写屏障&amp;gt;
STORE B=2
                             LOAD B
                             LOAD A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;没有干预的话, CPU 1的操作被CPU 2感知到的顺序是随机的, 尽管CPU 1执行了写屏障：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&amp;gt;| A=1  |------      ---&amp;gt;| A-&amp;gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&amp;gt;| B-&amp;gt;9  |
|       |       +------+        |       +-------+
|       |------&amp;gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                                |       +-------+       | CPU 2 |
                                |       | A-&amp;gt;0  |------&amp;gt;|       |
                                |       +-------+       |       |
                                |       :       :       +-------+
                                 \      :       :
                                  \     +-------+
                                   ----&amp;gt;| A-&amp;gt;1  |
                                        +-------+
                                        :       :
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是, 如果一个读屏障被放到CPU 2的LOAD B和LOAD A之间:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                        CPU 2
=======================      =======================
{ A = 0, B = 9 }
STORE A=1
&amp;lt;写屏障&amp;gt;
STORE B=2
                             LOAD B
                             &amp;lt;读屏障&amp;gt;
                             LOAD A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么CPU 1所施加的部分有序将正确的被CPU 2所感知:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&amp;gt;| A=1  |------      ---&amp;gt;| A-&amp;gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&amp;gt;| B-&amp;gt;9  |
|       |       +------+        |       +-------+
|       |------&amp;gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                |       :       :       |       |
  在这一时刻, 读屏障导致 ----&amp;gt;   \  rrrrrrrrrrrrrrrrr   |       |
  STORE B之前的影响都被           \     +-------+       |       |
  CPU 2所感知                      ----&amp;gt;| A-&amp;gt;1  |------&amp;gt;|       |
                                        +-------+       |       |
                                        :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了更全面地说明这一点, 考虑一下如果代码在读屏障的两边都有一个LOAD A的话, 会发生什么:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                        CPU 2
=======================      =======================
{ A = 0, B = 9 }
STORE A=1
&amp;lt;写屏障&amp;gt;
STORE B=2
                             LOAD B
                             LOAD A [第一次LOAD A]
                             &amp;lt;读屏障&amp;gt;
                             LOAD A [第二次LOAD A]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;尽管两次LOAD A都发生在LOAD B之后, 它们也可能得到不同的值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&amp;gt;| A=1  |------      ---&amp;gt;| A-&amp;gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&amp;gt;| B-&amp;gt;9  |
|       |       +------+        |       +-------+
|       |------&amp;gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                |       :       :       |       |
                                |       +-------+       |       |
                                |       | A-&amp;gt;0  |------&amp;gt;| 一次  |
                                |       +-------+       |       |
  在这一时刻, 读屏障导致 ----&amp;gt;   \  rrrrrrrrrrrrrrrrr   |       |
  STORE B之前的影响都被           \     +-------+       |       |
  CPU 2所感知                      ----&amp;gt;| A-&amp;gt;1  |------&amp;gt;| 二次  |
                                        +-------+       |       |
                                        :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是也可能CPU 2在读屏障结束之前就感知到CPU 1对A的更新:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&amp;gt;| A=1  |------      ---&amp;gt;| A-&amp;gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&amp;gt;| B-&amp;gt;9  |
|       |       +------+        |       +-------+
|       |------&amp;gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                 \      :       :       |       |
                                  \     +-------+       |       |
                                   ----&amp;gt;| A-&amp;gt;1  |------&amp;gt;| 一次  |
                                        +-------+       |       |
                                    rrrrrrrrrrrrrrrrr   |       |
                                        +-------+       |       |
                                        | A-&amp;gt;1  |------&amp;gt;| 二次  |
                                        +-------+       |       |
                                        :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里只保证, 如果LOAD B得到的值是2的话, 第二个LOAD A能得到的值是1. &lt;br /&gt;
对于第一个LOAD A是不存在这样的保证的; 它可能得到A的值是0或是1.&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;读内存屏障与内存预取&lt;/h3&gt;

&lt;p&gt;许多CPU会对LOAD操作进行预取: &lt;br /&gt;
作为性能优化的一种手段, 当CPU发现它们将要从内存LOAD一个数据时, 它们会寻找一个不需要使用总线来进行其他LOAD操作的时机, 用于LOAD这个数据&lt;br /&gt;
尽管他们的指令执行流程实际上还没有到达该处LOAD的地方. &lt;br /&gt;
实际上, 这可能使得某些LOAD指令能够立即完成, 因为CPU已经预取到了所需要LOAD的值.&lt;/p&gt;

&lt;p&gt;这也可能出现CPU实际上用不到这个预取的值的情况  &lt;br /&gt;
可能因为一个分支而避开了这次LOAD&lt;br /&gt;
在这样的情况下, CPU可以丢弃这个值或者干脆就缓存它以备后续使用.&lt;/p&gt;

&lt;p&gt;考虑如下场景:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                   CPU 2
======================= =======================
                        LOAD B
                        DIVIDE   } 除法指令通常消耗
                        DIVIDE   } 很长的执行时间
                        LOAD A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这可能将表现为如下情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                          :       :       +-------+
                          +-------+       |       |
                      ---&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                          +-------+       | CPU 2 |
                          :       :DIVIDE |       |
                          +-------+       |       |
CPU在执行除法指令 ---&amp;gt; --&amp;gt;| A-&amp;gt;0  |~~~~   |       |
的同时, 预取A             +-------+   ~   |       |
(译注: 此时总线空闲)      :       :   ~   |       |
                          :       :DIVIDE |       |
                          :       :   ~   |       |
   一旦除法结束,  --&amp;gt;     :       :   ~--&amp;gt;|       |
   CPU能马上使            :       :       |       |
   LOAD指令生效           :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果在第二个LOAD之前放一个读屏障或数据依赖屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                   CPU 2
======================= =======================
                        LOAD B
                        DIVIDE
                        DIVIDE
                        &amp;lt;读屏障&amp;gt;
                        LOAD A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这在一定程度上将迫使预取所获得的值, 根据屏障的类型而被重新考虑. &lt;br /&gt;
如果没有新的更新操作作用到已经被预取的内存地址, 则预取到的值就会被使用:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                          :       :       +-------+
                          +-------+       |       |
                      ---&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                          +-------+       | CPU 2 |
                          :       :DIVIDE |       |
                          +-------+       |       |
CPU在执行除法指令 ---&amp;gt; --&amp;gt;| A-&amp;gt;0  |~~~~   |       |
的同时, 预取A             +-------+   ~   |       |
                          :       :   ~   |       |
                          :       :DIVIDE |       |
                          :       :   ~   |       |
                          :       :   ~   |       |
                      rrrrrrrrrrrrrrrr~   |       |
                          :       :   ~   |       |
                          :       :   ~--&amp;gt;|       |
                          :       :       |       |
                          :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是, 如果存在一个来自于其他CPU的更新或失效, 那么预取将被取消, 并且重新载入值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                          :       :       +-------+
                          +-------+       |       |
                      ---&amp;gt;| B-&amp;gt;2  |------&amp;gt;|       |
                          +-------+       | CPU 2 |
                          :       :DIVIDE |       |
                          +-------+       |       |
CPU在执行除法指令 ---&amp;gt; --&amp;gt;| A-&amp;gt;0  |~~~~   |       |
的同时, 预取A             +-------+   ~   |       |
                          :       :   ~   |       |
                          :       :DIVIDE |       |
                          :       :   ~   |       |
                          :       :   ~   |       |
                      rrrrrrrrrrrrrrrrr   |       |
                          +-------+       |       |
预取被丢弃, 并且更 --&amp;gt; --&amp;gt;| A-&amp;gt;1  |------&amp;gt;|       |
新后的值被重新获取        +-------+       |       |
                          :       :       +-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-12&quot;&gt;内核中显式的内存屏障&lt;/h2&gt;

&lt;p&gt;linux内核拥有各式各样的屏障, 作用在不同层次上:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译优化屏障.&lt;/li&gt;
  &lt;li&gt;CPU内存屏障.&lt;/li&gt;
  &lt;li&gt;MMIO写屏障.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;编译优化屏障&lt;/h3&gt;

&lt;p&gt;Linux内核有一个显式的编译器屏障函数, 能够防止编译器优化将访存操作从它的任一侧移到另一侧:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;barrier();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个通用屏障 - 弱类型的编译优化屏障并不存在.&lt;/p&gt;

&lt;p&gt;编译优化屏障并不直接作用到CPU, CPU依然可以按其意愿乱序执行代码.&lt;/p&gt;

&lt;p&gt;既然编译优化屏障并不能限制CPU的乱序访存, 那么单纯的编译优化屏障能起到什么作用呢?&lt;/p&gt;

&lt;p&gt;以内核中的preempt_disable宏为例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define preempt_disable() \
do { \
        inc_preempt_count(); \
        barrier(); \
} while (0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;preempt_disable()&lt;/code&gt;和对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;preempt_enable()&lt;/code&gt;之间的代码是禁止内核抢占的, 通过对当前进程的preempt_count进行++, 以标识进入禁止抢占状态(preempt_count==0时可抢占). &lt;br /&gt;
这里在对preempt_count自增之后, 使用了编译优化屏障.&lt;/p&gt;

&lt;p&gt;如果不使用屏障, 本该在不可抢占状态下执行的指令可能被重排到preempt_count++之前(因为这些指令基本上不会对preempt_count有依赖). &lt;br /&gt;
而抢占可能是由中断处理程序来触发的, 在那些应该在不可抢占状态下执行的指令被执行之后, preempt_count++之前, 可能发生中断. &lt;br /&gt;
中断来了, preempt_count的值还是0, 于是进程可能会被错误的抢占掉.&lt;/p&gt;

&lt;p&gt;究其原因, 是因为编译器看到的上下文依赖逻辑是静态的, 它不知道这段代码跟中断处理程序还存在依赖关系, 所以没法限制自己的乱序行为. &lt;br /&gt;
所以, 这里的编译优化屏障是必要的.&lt;/p&gt;

&lt;p&gt;但是, 仅仅使用编译优化屏障就足够了么? &lt;br /&gt;
是的, 因为preempt_count这个变量是属于当前进程的, 仅会被当前CPU访问.&lt;/p&gt;

&lt;p&gt;CPU乱序可能导致后面应该在禁止抢占状态下执行的指令先于&lt;code class=&quot;highlighter-rouge&quot;&gt;preempt_disable()&lt;/code&gt;执行完,   但是没有关系, 因为前面也提到过, CPU是”顺序流入, 乱序流出”的, 就算后面的指令先执行完, &lt;code class=&quot;highlighter-rouge&quot;&gt;preempt_disable()&lt;/code&gt;也必定已经存在于流水线中了, CPU知道preempt_count变量将要被修改.  &lt;br /&gt;
而触发抢占的代码肯定会检查preempt_count是否为0, 而这里的检查又将依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;preempt_disable()&lt;/code&gt;的修改结果, 必定在preempt_disable()完成之后才会进行.&lt;/p&gt;

&lt;p&gt;究其原因, 是因为CPU看到的上下文依赖逻辑是动态的, 它不管指令是来自于普通的处理流程, 还是来自于中断处理程序, 只要指令存在依赖, 它都能发现. &lt;br /&gt;
所以, 对于类似这样的只被一个CPU所关注的内存访问, CPU的乱序访存并不会存在问题.&lt;/p&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU内存屏障&lt;/h3&gt;

&lt;p&gt;Linux内核有8种基本的CPU内存屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类型            强制                    SMP环境
=============== ======================= ===========================
通用            mb()                    smp_mb()
写              wmb()                   smp_wmb()
读              rmb()                   smp_rmb()
数据依赖        read_barrier_depends()  smp_read_barrier_depends()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里所说有SMP屏障是只在SMP环境下才生效的屏障, 而强制屏障则是不管在不在SMP环境下都生效的屏障. &lt;br /&gt;
这里所谓的SMP环境, 确切的说, 其实是内核的编译选项指定为SMP的情况, 并不是指实际运行内核的机器的环境. &lt;br /&gt;
不过既然编译选项指定了SMP环境, 那么编译生成的内核也基本上将会运行在SMP环境. &lt;br /&gt;
下面提到的UP环境亦是同理.&lt;/p&gt;

&lt;p&gt;除了数据依赖屏障之外, 所有的内存屏障都隐含了编译优化屏障的功能. &lt;br /&gt;
数据依赖屏障不对编译器输出的代码顺序造成任何额外的影响.&lt;/p&gt;

&lt;p&gt;在存在数据依赖关系的情况下, 编译器预期会将LOAD指令按正确的顺序输出(例如, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;a[b]&lt;/code&gt;语句中, 对b的load必须放在对a[b]的load之前).&lt;br /&gt;
但在C规范下, 并不保证编译器不去预测B的值(比如预测它等于1), 于是先load a再load b(比如, &lt;code class=&quot;highlighter-rouge&quot;&gt;tmp = a[1]; if (b != 1) tmp = a[b];&lt;/code&gt;). &lt;br /&gt;
编译器在load a[b]之后又重新load b, 也可能会存在问题, 因为b拥有比a[b]更新的副本. &lt;br /&gt;
这些问题的解决尚未达成共识, 然而内核中的ACCESS_ONCE宏是解决问题的一个好的开始.&lt;/p&gt;

&lt;p&gt;在UP系统中, SMP内存屏障将退化成编译器优化屏障, 因为它假定CPU能够保证自身的一致性, 并本身就能以正确的顺序处理重叠的内存访问.&lt;/p&gt;

&lt;p&gt;注意, SMP内存屏障必须用于控制在SMP系统中的共享内存的引用顺序, 而使用锁也能够满足需求.&lt;/p&gt;

&lt;p&gt;强制屏障不应该用来控制SMP的影响, 因为强制屏障会过多地增加UP系统的开销. &lt;br /&gt;
不过, 在使用MMIO来访问松散属性的IO内存窗口时, 强制屏障可以用来控制这些访存的影响.&lt;/p&gt;

&lt;p&gt;这里所指的内存窗口, 是假定对于CPU来说, 可以设置属于不同区间的内存地址拥有不同的属性. &lt;br /&gt;
这些属性可以指示一个内存段是否可以松散访问, 即乱序访问.&lt;br /&gt;
强制屏障即使在非SMP环境下也可能需要, 因为它们可以通过禁止编译器和CPU的乱序访存, 从而影响设备感知到内存操作的顺序.&lt;/p&gt;

&lt;p&gt;还有一些更高级的屏障函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_mb(var, value)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该函数将value赋值到var变量中, 然后取决于具体编译参数下的函数实现, 可能在之后插入一个内存屏障. &lt;br /&gt;
在UP系统中, 它不能保证会插入编译优化屏障以外的其他屏障.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; smp_mb__before_atomic_dec();
 smp_mb__after_atomic_dec();
 smp_mb__before_atomic_inc();
 smp_mb__after_atomic_inc();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它们跟一些进行原子操作的函数配合使用, 这些函数进行了原子加法, 减法, 自增和自减, 而又不将原子变量的值返回, 特别被用于引用计数. &lt;br /&gt;
这些原子操作本身并不隐含内存屏障. &lt;br /&gt;
像这样被操作的原子变量, 多半是孤立而没有数据依赖的. &lt;br /&gt;
如果有数据依赖, 那么依赖关系将在一定程度上限制CPU的乱序. &lt;br /&gt;
否则, CPU的乱序就完全要靠内存屏障来限制了.&lt;/p&gt;

&lt;p&gt;举个例子, 考虑如下代码段, 它将object标识为已删除, 然后将其引用计数自减:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj-&amp;gt;dead = 1;
smp_mb__before_atomic_dec();
atomic_dec(&amp;amp;obj-&amp;gt;ref_count);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样可以确保设置删除标记在自减引用计数之前生效.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;smp_mb__before_clear_bit(void);
smp_mb__after_clear_bit(void);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它们的用途类似于原子加减的屏障. &lt;br /&gt;
它们通常是跟一些进行按位解锁操作的函数配合使用, 必须小心, 因为位操作本身也并不隐含内存屏障.&lt;/p&gt;

&lt;p&gt;考虑这样一个场景, 程序通过清除锁定位来实施一些解锁性质的操作. &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;clear_bit()&lt;/code&gt;函数需要像这样的屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;smp_mb__before_clear_bit();
clear_bit( ... );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样可以防止应该在锁定位被清除之前发生的内存操作漏到位清除之后去.&lt;br /&gt;
注意UNLOCK的屏障作用就是要保证它之前的访存操作一定先于它而完成.&lt;/p&gt;

&lt;h3 id=&quot;mmio&quot;&gt;MMIO写屏障&lt;/h3&gt;

&lt;p&gt;对于内存映射IO的写操作, Linux内核还有一个特别的屏障:&lt;code class=&quot;highlighter-rouge&quot;&gt;mmiowb()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这是一个强制写屏障的变体, 能够将弱有序的IO内存窗口变成部分有序. &lt;br /&gt;
它的作用可能超出CPU与硬件的界面, 从而影响到许多层次上的硬件设备.&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;内核中隐式的内存屏障&lt;/h2&gt;

&lt;p&gt;Linux内核中有一些其他的方法也隐含了内存屏障, 包括锁和调度方法.&lt;/p&gt;

&lt;p&gt;这个范围是一个最低限度的保证; 一些特定的体系结构可能提供更多的保证, 但是在特定体系结构的代码之外, 不能依赖于它们.&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;锁相关函数&lt;/h3&gt;

&lt;p&gt;Linux内核有很多锁结构:&lt;/p&gt;

&lt;p&gt;*) spin locks&lt;br /&gt;
*) R/W spin locks&lt;br /&gt;
*) mutexes&lt;br /&gt;
*) semaphores&lt;br /&gt;
*) R/W semaphores&lt;br /&gt;
*) RCU&lt;/p&gt;

&lt;p&gt;在所有情况下, 它们都是LOCK操作和UNLOCK操作的变种. &lt;br /&gt;
这些操作都隐含一定的屏障:&lt;/p&gt;

&lt;p&gt;1) LOCK操作所隐含的:&lt;br /&gt;
   在LOCK操作之后出现的内存操作, 一定在LOCK操作完成之后才会完成. &lt;br /&gt;
   而在LOCK操作之前出现的内存操作, 可能在LOCK操作完成之后才完成.&lt;br /&gt;
2) UNLOCK操作所隐含的:&lt;br /&gt;
   在UNLOCK操作之前出现的内存操作, 一定在UNLOCK操作完成之前完成.&lt;br /&gt;
   而在UNLOCK操作之后出现的内存操作, 可能在LOCK操作完成之前就完成了.&lt;br /&gt;
3) LOCK操作+LOCK操作所隐含的:&lt;br /&gt;
   在某个LOCK操作之前出现的所有LOCK操作都将在这个LOCK之前完成.&lt;br /&gt;
4) LOCK操作+UNLOCK操作所隐含的: &lt;br /&gt;
   在UNLOCK操作之前出现的所有LOCK操作都将在这个UNLOCK之前完成.&lt;br /&gt;
   在LOCK操作之前出现的所有UNLOCK操作都将在这个LOCK之前完成.&lt;br /&gt;
5) LOCK失败所隐含的: &lt;br /&gt;
   某些变种的LOCK操作可能会失败, 比如可能因为不能立刻获得锁,如try_lock操作&lt;br /&gt;
   再比如因为在睡眠等待锁变为可用的过程中接收到了未被阻塞的信号,如semaphores的down_interruptible操作.&lt;br /&gt;
   失败的锁操作不隐含任何屏障.&lt;/p&gt;

&lt;p&gt;因此, 根据(1), (2)和(4), 一个无条件的LOCK跟在一个UNLOCK之后, 锁相当于一个完整的屏障, 而一个UNLOCK跟在一个LOCK之后并非如此.&lt;/p&gt;

&lt;p&gt;注意: LOCK和UNLOCK只是单向的屏障, 其结果是, 临界区之外的指令可能会在临界区中执行.&lt;/p&gt;

&lt;p&gt;一个UNLOCK跟在一个LOCK之后并不能认为是一个完整的屏障, 因为出现在LOCK之前的访存可能在LOCK之后才执行, 而出现在UNLOCK之后的访存可能在UNLOCK之前执行, 这两次访存可能会交叉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = a;
LOCK
UNLOCK
*B = b;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可能表现为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCK, STORE *B, STORE *A, UNLOCK
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;锁和信号量在UP环境下可能不提供顺序保证, 在这种情况下不能被认作是真正的屏障 - 特别是对于IO访问 - 除非结合中断禁用操作.&lt;/p&gt;

&lt;p&gt;例如, 考虑如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = a;
*B = b;
LOCK
*C = c;
*D = d;
UNLOCK
*E = e;
*F = f;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如下的事件序列都是可接受的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCK, {*F,*A}, *E, {*C,*D}, *B, UNLOCK
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意, &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*F,*A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; 代表一次合并访问.&lt;/p&gt;

&lt;p&gt;但是下面的序列都不可接受:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*F,*A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*B,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*C,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*D,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;UNLOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*E&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*A,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*B,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*C,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*D,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;UNLOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*E,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*F&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*A,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*B,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;         &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*C,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;UNLOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*D,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*E,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*F&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*B,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;             &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*C,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*D,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;UNLOCK,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*F,*A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*E&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-16&quot;&gt;禁止中断函数&lt;/h3&gt;

&lt;p&gt;禁止中断(类似于LOCK)和启用中断(类似于UNLOCK)的函数只会起到编译优化屏障的作用. &lt;br /&gt;
所以, 如果在这种情况下需要使用内存或IO屏障, 必须采取其他手段.&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;睡眠唤醒函数&lt;/h3&gt;

&lt;p&gt;在一个全局事件标记上的睡眠和唤醒可以被看作是两条数据之间的交互: 正在等待事件的进程的状态, 和用于表示事件发生的全局数据. &lt;br /&gt;
为了确保它们按正确的顺序发生, 进入睡眠的原语和发起唤醒的原语都隐含了某些屏障.&lt;/p&gt;

&lt;p&gt;首先, 睡眠进程通常执行类似于如下的代码序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (;;) {
    set_current_state(TASK_UNINTERRUPTIBLE);
    if (event_indicated)
            break;
    schedule();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set_current_state()&lt;/code&gt;在它更改进程状态之后会自动插入一个通用内存屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1
===============================
set_current_state();
  set_mb();
    STORE current-&amp;gt;state
    &amp;lt;通用屏障&amp;gt;
LOAD event_indicated
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set_current_state()&lt;/code&gt;可能被包装在以下函数中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prepare_to_wait();
prepare_to_wait_exclusive();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因此这些函数也隐含了一个在设置了进程状态之后的通用内存屏障. &lt;br /&gt;
以上的各个函数又被包装在其他一些函数中, 所有这些包装函数都相当于在对应的位置插入了内存屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wait_event();
wait_event_interruptible();
wait_event_interruptible_exclusive();
wait_event_interruptible_timeout();
wait_event_killable();
wait_event_timeout();
wait_on_bit();
wait_on_bit_lock();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其次, 用作唤醒操作的代码通常是下面这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;event_indicated = 1;
wake_up(&amp;amp;event_wait_queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;event_indicated = 1;
wake_up_process(event_daemon);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似&lt;code class=&quot;highlighter-rouge&quot;&gt;wake_up()&lt;/code&gt;的函数会隐含一个写内存屏障. 当且仅当它们的确唤醒了某个进程时. &lt;br /&gt;
屏障出现在进程的睡眠状态被清除之前, 也就是在设置唤醒事件标记的STORE操作和将进程状态修改为TASK_RUNNING的STORE操作之间:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                           CPU 2
=============================== ===============================
set_current_state();            STORE event_indicated
  set_mb();                       wake_up();
    STORE current-&amp;gt;state            &amp;lt;写屏障&amp;gt;
    &amp;lt;通用屏障&amp;gt;                      STORE current-&amp;gt;state
LOAD event_indicated
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可用的唤醒函数包括:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;complete();
wake_up();
wake_up_all();
wake_up_bit();
wake_up_interruptible();
wake_up_interruptible_all();
wake_up_interruptible_nr();
wake_up_interruptible_poll();
wake_up_interruptible_sync();
wake_up_interruptible_sync_poll();
wake_up_locked();
wake_up_locked_poll();
wake_up_nr();
wake_up_poll();
wake_up_process();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意, 对于唤醒函数读写事件之前, 睡眠函数调用&lt;code class=&quot;highlighter-rouge&quot;&gt;set_current_state()&lt;/code&gt;之后的那些STORE操作, 睡眠和唤醒所隐含的内存屏障并不保证它们的顺序. &lt;br /&gt;
比如说, 如果睡眠函数这样做:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_current_state(TASK_INTERRUPTIBLE);
if (event_indicated)
        break;
__set_current_state(TASK_RUNNING);
do_something(my_data);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而唤醒函数这样做:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_data = value;
event_indicated = 1;
wake_up(&amp;amp;event_wait_queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;睡眠函数并不能保证在看到my_data的修改之后才看到event_indicated的修改. &lt;br /&gt;
在这种情况下, 两边的代码必须在对my_data访存之前插入自己的内存屏障. &lt;br /&gt;
因此上述的睡眠函数应该这样做:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_current_state(TASK_INTERRUPTIBLE);
if (event_indicated) {
        smp_rmb();
        do_something(my_data);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而唤醒函数应该这样做:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_data = value;
smp_wmb();
event_indicated = 1;
wake_up(&amp;amp;event_wait_queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-18&quot;&gt;其他函数&lt;/h3&gt;

&lt;p&gt;其他隐含了屏障的函数:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;和类似函数隐含了完整的内存屏障.&lt;br /&gt;
schedule函数完成了进程的切换, 它的两边可能对应着两个不同的上下文. &lt;br /&gt;
如果访存操作跨越schedule函数而进行了乱序, 那么基本上可以肯定是错误的.&lt;/p&gt;

&lt;h2 id=&quot;cpu-1&quot;&gt;跨CPU的锁的屏障作用&lt;/h2&gt;

&lt;p&gt;在SMP系统中, 锁定原语给出了多种形式的屏障: 其中一种在一些特定的锁冲突的情况下, 会影响其他CPU上的内存访问顺序.&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;锁与内存访问&lt;/h3&gt;

&lt;p&gt;假设系统中有(M)和(Q)这一对spinlock, 有三个CPU; 那么可能发生如下操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CPU 1                           CPU 2
 =============================== ===============================
 *A = a;                         *E = e;
 LOCK M                          LOCK Q
 *B = b;                         *F = f;
 *C = c;                         *G = g;
 UNLOCK M                        UNLOCK Q
 *D = d;                         *H = h;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么对于CPU 3来说, 从&lt;em&gt;A到&lt;/em&gt;H的访问顺序是没有保证的, 不像单独的锁对应单独的CPU有那样的限制. &lt;br /&gt;
例如, CPU 3可能看到的顺序是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*E, LOCK M, LOCK Q, *G, *C, *F, *A, *B, UNLOCK Q, *D, *H, UNLOCK M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是它不会看到如下情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*B, *C or *D 先于 LOCK M
*A, *B or *C 后于 UNLOCK M
*F, *G or *H 先于 LOCK Q
*E, *F or *G 后于 UNLOCK Q
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是, 如果是下面的情形:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        CPU 1                           CPU 2
        =============================== ===============================
        *A = a;
        LOCK M          [1]
        *B = b;
        *C = c;
        UNLOCK M        [1]
        *D = d;                         *E = e;
                                        LOCK M          [2]
                                        *F = f;
                                        *G = g;
                                        UNLOCK M        [2]
                                        *H = h;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CPU 3可能看到:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*E, LOCK M [1], *C, *B, *A, UNLOCK M [1],
LOCK M [2], *H, *F, *G, UNLOCK M [2], *D
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是如果CPU 1先得到锁, CPU 3不会看到下面的情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*B, *C, *D, *F, *G or *H 先于 LOCK M [1]
*A, *B or *C 后于 UNLOCK M [1]
*F, *G or *H 先于 LOCK M [2]
*A, *B, *C, *E, *F or *G 后于 UNLOCK M [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;io&quot;&gt;锁与IO访问&lt;/h3&gt;

&lt;p&gt;在某些情况下(特别是涉及到NUMA的情况), 两个CPU上发起的属于两个spinlock临界区的IO访问可能被PCI桥看成是交错发生的, 因为PCI桥并不一定参与cache一致性协议, 以至于无法响应读内存屏障.&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                                CPU 2
===============================      ===============================
spin_lock(Q)
writel(0, ADDR)
writel(1, DATA);
spin_unlock(Q);
                                     spin_lock(Q);
                                     writel(4, ADDR);
                                     writel(5, DATA);
                                     spin_unlock(Q);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PCI桥可能看到的是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STORE *ADDR = 0, STORE *ADDR = 4, STORE *DATA = 1, STORE *DATA = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这可能会引起硬件操作的错误.&lt;/p&gt;

&lt;p&gt;这里所需要的是, 在释放spinlock之前, 使用mmiowb()作为干预, 例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                                CPU 2
===============================      ===============================
spin_lock(Q)
writel(0, ADDR)
writel(1, DATA);
mmiowb();
spin_unlock(Q);
                                     spin_lock(Q);
                                     writel(4, ADDR);
                                     writel(5, DATA);
                                     mmiowb();
                                     spin_unlock(Q);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就能确保CPU 1的两次STORE操作先于CPU 2的STORE操作被PCI桥所看到.&lt;/p&gt;

&lt;p&gt;此外, 对于同一硬件设备在进行STORE操作之后再进行LOAD操作, 可以省去mmiowb(), 因为LOAD操作将强制STORE操作在开始LOAD之前就完成:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                                CPU 2
===============================      ===============================
spin_lock(Q)
writel(0, ADDR)
a = readl(DATA);
spin_unlock(Q);
                                     spin_lock(Q);
                                     writel(4, ADDR);
                                     b = readl(DATA);
                                     spin_unlock(Q);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-20&quot;&gt;什么地方需要内存屏障?&lt;/h2&gt;

&lt;p&gt;在正常操作下, 内存操作的乱序一般并不会成为问题, 即使是在SMP内核中, 一段单线程的线性代码也总是能够正确工作. &lt;br /&gt;
但是, 有四种情况, 乱序绝对可能是一个问题:&lt;/p&gt;

&lt;p&gt;*) 处理器间交互.&lt;br /&gt;
*) 原子操作.&lt;br /&gt;
*) 访问设备.&lt;br /&gt;
*) 中断.&lt;/p&gt;

&lt;h3 id=&quot;section-21&quot;&gt;处理器间交互&lt;/h3&gt;

&lt;p&gt;当系统中拥有不止一个CPU时, 系统中的多个CPU可能在同一时间工作在同样的数据集上. &lt;br /&gt;
这将产生同步问题, 并且这样的问题通常要靠使用锁来解决. &lt;br /&gt;
但是, 锁是昂贵的, 所以不是万不得已的情况下最好不要使用锁. &lt;br /&gt;
在这种情况下, 为防止错误, 导致两个CPU相互影响的那些内存操作可能需要仔细协调好顺序.&lt;/p&gt;

&lt;p&gt;比如, 考虑一下读写信号量的slow path. &lt;br /&gt;
信号量的等待队列里有一个进程正在等待, 这个等待进程栈空间上的一段内存(译注: 也就是栈上分配的waiter结构)被链到信号量的等待链表里:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct rw_semaphore {
        ...
        spinlock_t lock;
        struct list_head waiters;
};

struct rwsem_waiter {
        struct list_head list;
        struct task_struct *task;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要唤醒这样一个等待进程, up_read()函数或up_write()函数需要这样做:&lt;/p&gt;

&lt;p&gt;1) 读取该等待进程所对应的waiter结构的next指针, 以记录下一个等待进程是谁;&lt;br /&gt;
2) 读取waiter结构中的task指针, 以获取对应进程的进程控制块;&lt;br /&gt;
3) 清空waiter结构中的task指针, 以表示这个进程正在获得信号量;&lt;br /&gt;
4) 对这个进程调用wake_up_process()函数; 并且&lt;br /&gt;
5) 释放waiter结构对进程控制块的引用计数.&lt;/p&gt;

&lt;p&gt;换句话说, 这个过程会执行如下事件序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOAD waiter-&amp;gt;list.next;
LOAD waiter-&amp;gt;task;
STORE waiter-&amp;gt;task;
CALL wakeup
RELEASE task
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而如果其中一些步骤发生了乱序, 那么整个过程可能会产生错误.&lt;/p&gt;

&lt;p&gt;一旦等待进程将自己挂入等待队列, 并释放了信号量里的锁, 这个等待进程就不会再获得这个锁了(译注: 参阅信号量的代码, 它内部使用了一个spinlock来进行同步);&lt;br /&gt;
它要做的事情就是在继续工作之前, 等待waiter结构中的task指针被清空(译注: 然后自己会被唤醒). &lt;br /&gt;
而既然waiter结构存在于等待进程的栈上, 这就意味着, 如果在waiter结构中的next指针被读取之前, task指针先被清空了的话(译注: 等待进程先被唤醒了), &lt;br /&gt;
那么, 这个等待进程可能已经在另一个CPU上开始运行了(译注: 相对于唤醒进程所运行的CPU), 并且在up&lt;em&gt;()函数有机会读取到next指针之前, 栈空间上对应的waiter结构可能已经被复用了&lt;br /&gt;
(译注: 被唤醒的进程从down&lt;/em&gt;()函数返回, 然后可能进行新的函数调用, 导致栈空间被重复使用)&lt;/p&gt;

&lt;p&gt;看看上面的事件序列可能会发生什么:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1                           CPU 2
=============================== ===============================
                                down_xxx()
                                将waiter结构链入等待队列
                                进入睡眠
up_yyy()
LOAD waiter-&amp;gt;task;
STORE waiter-&amp;gt;task;
                                被CPU 1的UP事件唤醒
&amp;lt;被抢占了&amp;gt;
                                重新得到运行
                                down_xxx()函数返回
                                继续调用foo()函数
                                foo()重用了栈上的waiter结构
&amp;lt;抢占返回&amp;gt;
LOAD waiter-&amp;gt;list.next;
--- OOPS ---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对付这个问题可以使用信号量中的锁, 但是当进程被唤醒后, down_xxx()函数其实没必要重新获得这个spinlock.&lt;/p&gt;

&lt;p&gt;实际的解决办法是插入一个通用SMP内存屏障:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOAD waiter-&amp;gt;list.next;
LOAD waiter-&amp;gt;task;
smp_mb();
STORE waiter-&amp;gt;task;
CALL wakeup
RELEASE task
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样, 对于系统中的其他CPU来说, 屏障将保证屏障之前的所有内存访问先于屏障之后的所有内存访问发生. &lt;br /&gt;
屏障并不保证屏障之前的所有内存访问都在屏障指令结束之前完成.&lt;/p&gt;

&lt;p&gt;在UP系统中 - 这种情况将不是问题 - smp_mb()函数只是一个编译优化屏障, 这就确保了编译器生成顺序正确的指令, 而不需要干预CPU. &lt;br /&gt;
既然只有一个CPU, 该CPU的数据依赖逻辑将处理所有事情.&lt;/p&gt;

&lt;h3 id=&quot;section-22&quot;&gt;原子操作&lt;/h3&gt;

&lt;p&gt;虽然原子操作在技术上实现了处理器之间的交互, 然而特别注意一些原子操作隐含了完整的内存屏障, 而另外一些则没有, 但是它们却作为一个群体被整个内核严重依赖.&lt;/p&gt;

&lt;p&gt;许多原子操作修改内存中的一些状态, 并且返回该状态相关的信息(旧状态或新状态), 就在其中实际操作内存的两边各隐含一个SMP环境下的通用内存屏障(smp_mb())(除显式的锁操作之外, 稍后说明). &lt;br /&gt;
它们包括:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xchg();
cmpxchg();
atomic_cmpxchg();
atomic_inc_return();
atomic_dec_return();
atomic_add_return();
atomic_sub_return();
atomic_inc_and_test();
atomic_dec_and_test();
atomic_sub_and_test();
atomic_add_negative();
atomic_add_unless();        /* 如果成功 (返回 1) */
test_and_set_bit();
test_and_clear_bit();
test_and_change_bit();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它们被用于作为类LOCK和类UNLOCK操作的实现, 和用于控制对象析构的引用计数, 这些情况下, 隐含内存屏障是有必要的.&lt;/p&gt;

&lt;p&gt;以下操作由于没有隐含内存屏障, 会有潜在的问题, 但有可能被用于实现类UNLOCK这样的操作:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;atomic_set();
set_bit();
clear_bit();
change_bit();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果需要, 对应于这些函数, 可以使用相应的显式内存屏障(比如&lt;code class=&quot;highlighter-rouge&quot;&gt;smp_mb__before_clear_bit()&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;下面这些函数也不隐含内存屏障, 并且在一些情况下, 可能也需要用到显式内存屏障(比如&lt;code class=&quot;highlighter-rouge&quot;&gt;smp_mb__before_atomic_dec()&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;atomic_add();
atomic_sub();
atomic_inc();
atomic_dec();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果它们用于产生统计, 那么他们可能就不需要内存屏障, 除非统计数据之间存在耦合.&lt;/p&gt;

&lt;p&gt;如果它们被用作控制对象生命周期的引用计数, 那么它们可能并不需要内存屏障, 因为要么引用计数需要在一个锁的临界区里面进行调整, 要么调用者已经持有足够的引用而相当于拥有了锁&lt;br /&gt;
(译注: 一般在引用计数减为0的时候需要将对应的对象析构, 如果调用者知道引用计数在某些情况下不可能减为0, 那么这个对象也就不可能在这些情况下被析构, 也就不需要通过内存屏障来避免访存乱序导致的对象在析构之后还被访问的情况), 这样的情况下并不需要内存屏障.&lt;/p&gt;

&lt;p&gt;如果它们用于构成锁的一些描述信息, 那么他们可能就需要内存屏障, 因为锁原语一般需要按一定的顺序来操作.&lt;/p&gt;

&lt;p&gt;基本上, 每个场景都需要仔细考虑是否需要使用内存屏障.&lt;/p&gt;

&lt;p&gt;以下操作是特殊的锁原语:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test_and_set_bit_lock();
clear_bit_unlock();
__clear_bit_unlock();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它们都执行了类LOCK和类UNLOCK的操作. &lt;br /&gt;
相比其他操作, 它们应该优先被用于实现锁原语, 因为它们的实现可以在许多体系结构下得到优化.&lt;/p&gt;

&lt;p&gt;注意, 这些特殊的内存屏障原语对一些情况也是有用的, 因为在一些体系结构的CPU上,使用的原子操作本身就隐含了完整的内存屏障功能, 所以屏障指令在这里是多余的, 在这样的情况下, 这些特殊的屏障原语将不使用额外的屏障操作.&lt;/p&gt;

&lt;h3 id=&quot;section-23&quot;&gt;访问设备&lt;/h3&gt;

&lt;p&gt;许多设备都可以被映射到内存, 因此在CPU看来, 它们只是一组内存地址. &lt;br /&gt;
为了控制这些设备, 驱动程序通常需要确保正确的内存访问按正确的顺序来执行.&lt;/p&gt;

&lt;p&gt;但是, 聪明的CPU或者聪明的编译器却导致了潜在的问题, 如果CPU或编译器认为乱序, 或合并访问更有利于效率的话, 驱动程序代码中仔细安排的访存序列可能并不会按正确的顺序被送到设备上 - 从而可能导致设备的错误.&lt;/p&gt;

&lt;p&gt;在Linux内核里面, IO访问应该使用适当的访问函数 - 例如inb()或writel() - 它们知道如何得到恰当的访问顺序. &lt;br /&gt;
大多数情况下, 在使用这些函数之后就不必再显式的使用内存屏障, 但是在两种情况下, 内存屏障可能还是需要的:&lt;/p&gt;

&lt;p&gt;1) 在一些系统中, IO存储操作对于所有CPU来说并不是严格有序的, 所以对于所有的通用驱动程序(译注: 通用驱动程序需要适应各种体系结构的系统), 需要使用锁, 并且一定要在解锁临界区之前执行mmiowb()函数.&lt;br /&gt;
2) 如果访存函数访问松散属性的IO内存窗口, 那么需要使用强制内存屏障来确保执行顺序.&lt;/p&gt;

&lt;h3 id=&quot;section-24&quot;&gt;中断&lt;/h3&gt;

&lt;p&gt;驱动程序可能被它自己的中断处理程序所打断, 然后驱动程序中的这两个部分可能会相互干扰对方控制或访问设备的意图.&lt;/p&gt;

&lt;p&gt;通过禁用本地中断(一种形式的锁)可能至少部分缓解这种情况, 这样的话, 驱动程序中的关键操作都将包含在禁用中断的区间中. &lt;br /&gt;
于是当驱动程序的中断处理程序正在执行时, 驱动程序的核心代码不可能在相同的CPU上运行, 并且在当前中断被处理完之前中断处理程序不允许再次被调用, 于是中断处理程序就不需要再对这种情况使用锁.&lt;/p&gt;

&lt;p&gt;但是, 考虑一个驱动程序正通过一个地址寄存器和一个数据寄存器跟以太网卡交互的情况.&lt;br /&gt;
假设驱动程序的核心代码在禁用中断的情况下操作了网卡, 然后驱动程序的中断处理程序被调用:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL IRQ DISABLE
writew(ADDR, 3);
writew(DATA, y);
LOCAL IRQ ENABLE
&amp;lt;进入中断&amp;gt;
writew(ADDR, 4);
q = readw(DATA);
&amp;lt;退出中断&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果执行顺序的规则足够松散, 对数据寄存器的写操作可能发生在第二次对地址寄存器的写操作之后:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STORE *ADDR = 3, STORE *ADDR = 4, STORE *DATA = y, q = LOAD *DATA
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果执行顺序像这样松散, 就需要假定在禁用中断区间内应该完成的访问可能泄漏到区间之外, 并且可能漏到中断过程中进行访问 - 反之亦然 - 除非使用隐式或显式的屏障.&lt;/p&gt;

&lt;p&gt;通常这并不是一个问题, 因为禁用中断区间内完成的IO访存将会包含严格有序的同步LOAD操作, 形成隐式的IO屏障. &lt;br /&gt;
如果这还不够, 那么需要显式的调用一下mmiowb().&lt;/p&gt;

&lt;p&gt;在一个中断服务程序与两个运行在不同CPU的程序相互通信的情况下, 类似的情况也可能发生. &lt;br /&gt;
如果出现这样的情况, 那么禁用中断的锁操作需要用于确保执行顺序. (译注: 也就是类似于spinlock_irq这样的操作.)&lt;/p&gt;

&lt;h2 id=&quot;io-1&quot;&gt;内核中I/O屏障的作用&lt;/h2&gt;

&lt;p&gt;在对IO内存进行存取的时候, 驱动程序应该使用适当的存取函数:&lt;/p&gt;

&lt;p&gt;*) inX(), outX():&lt;br /&gt;
   它们都是倾向于跟IO空间打交道, 而不是普通内存空间, 不过这主要取决于具体CPU的逻辑. &lt;br /&gt;
   i386和x86_64处理器确实有特殊的IO空间存取周期和指令, 但是许多系统结构的CPU却并没有这些概念.&lt;/p&gt;

&lt;p&gt;包括PCI总线也可能会定义成IO空间 - 比如在i386和x86_64的CPU上 - 很容易将它映射到CPU的IO空间上. &lt;br /&gt;
   但是, 它也可能作为虚拟的IO空间被映射到CPU的内存空间上, 特别对于那些不支持IO空间的CPU.&lt;/p&gt;

&lt;p&gt;访问这些空间可能是完全同步的(比如在i386上), 但是对于桥设备(比如PCI主桥)可能并不完全是这样.&lt;/p&gt;

&lt;p&gt;他们能保证完全遵守IO操作之间的访问顺序.&lt;/p&gt;

&lt;p&gt;他们不能保证完全遵从IO操作与其他类型的内存操作之间的访问顺序.&lt;br /&gt;
*) readX(), writeX():&lt;br /&gt;
   在发起调用的CPU上, 这些函数是否保证完全遵从内存访问顺序而且不进行合并访问,取决于它们所访问的内存窗口上定义的属性. &lt;br /&gt;
   例如, 较新的i386体系结构的机器, 可以通过MTRR寄存器来控制内存窗口的属性.&lt;/p&gt;

&lt;p&gt;通常, 只要不是访问预取设备, 这些函数将保证完全有序并且不进行合并访问.&lt;/p&gt;

&lt;p&gt;但是对于桥设备(比如PCI桥), 如果它们愿意的话, 可能会倾向于对内存操作进行延迟处理; &lt;br /&gt;
   要冲刷一个STORE操作, 首选是对相同地址进行一次LOAD[*], 但是对于PCI来说, 对相同设备或相同的配置的IO空间进行一次LOAD就足够了.&lt;/p&gt;

&lt;p&gt;注意! 试图从刚写过的地址LOAD数据, 可能会导致错误 - 比如对于16550 Rx/Tx串口寄存器.&lt;/p&gt;

&lt;p&gt;遇到带预取的IO内存, 可能需要使用mmiowb()屏障来强制让STORE操作有序.&lt;/p&gt;

&lt;p&gt;关于PCI事务交互方面的更多信息, 请参阅PCI规范.&lt;/p&gt;

&lt;p&gt;*) readX_relaxed()
   这些函数类似于readX(), 但是任何情况下都不保证有序. 请注意, 这里没有用到IO读屏障.&lt;/p&gt;

&lt;p&gt;*) ioreadX(), iowriteX()
   这些函数在进行访存的时候会根据访存类型选择适当的操作, inX()/outX()或readX()/writeX().&lt;/p&gt;

&lt;h2 id=&quot;section-25&quot;&gt;最小限度有序的假想模型&lt;/h2&gt;

&lt;p&gt;从概念上说, 必须假定的CPU是弱有序的, 但是它会保持程序上下文逻辑关系的外观. &lt;br /&gt;
一些CPU(比如i386或x86_64)比另一些(比如powerpc或frv)更具有约束力, 而在体系结构无关的代码中, 必须假定为最松散的情况(也就是DEC Alpha).&lt;/p&gt;

&lt;p&gt;也就是说, 必须考虑到CPU可能会按它喜欢的顺序来执行操作 - 甚至并行执行 - 只是当指令流中的一条指令依赖于之前的一条指令时, 之前的这条指定才必须在后面这条指令可能被处理之前完全结束; 换句话说: 保持程序的上下文逻辑关系.&lt;/p&gt;

&lt;p&gt;一些指令会产生不止一处影响 - 比如会修改条件码, 修改寄存器或修改内存 - 不同的指令可能依赖于不同的影响.&lt;/p&gt;

&lt;p&gt;CPU也可能丢弃那些最终不产生任何影响的操作序列. &lt;br /&gt;
比如, 如果两个相邻的指令都将一个立即数LOAD到寄存器, 那么第一个LOAD指令可能被丢弃.&lt;/p&gt;

&lt;p&gt;类似的, 也需要假设编译器可能按它觉得舒服的顺序来调整指令流, 但同样也会保持程序的上下文逻辑关系.&lt;/p&gt;

&lt;h2 id=&quot;cpu-cache&quot;&gt;CPU cache的影响&lt;/h2&gt;

&lt;p&gt;操作cache中缓存的内存之后, 相应的影响会在整个系统间得到传播. &lt;br /&gt;
位于CPU和内存之间的cache, 和保持系统状态一致的内存一致性机构, 在一定程度上影响了传播的方法.&lt;/p&gt;

&lt;p&gt;自从CPU与系统中其他部分的交互通过使用cache来实现以来, 内存系统就包含了CPU的缓存,而内存屏障基本上就工作在CPU和其cache之间的界面上(逻辑上说, 内存屏障工作在下图中虚线所示的地方):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     &amp;lt;--- CPU ---&amp;gt;         :       &amp;lt;----------- 内存 -----------&amp;gt;
                           :
 +--------+    +--------+  :   +--------+    +-----------+
 |        |    |        |  :   |        |    |           |    +--------+
 |  CPU   |    |  内存  |  :   | CPU    |    |           |    |        |
 |  核心  |---&amp;gt;|  请求  |-----&amp;gt;| Cache  |&amp;lt;--&amp;gt;|           |    |        |
 |        |    |  队列  |  :   |        |    |           |---&amp;gt;|  内存  |
 |        |    |        |  :   |        |    |           |    |        |
 +--------+    +--------+  :   +--------+    |           |    |        |
                           :                 |  Cache    |    +--------+
                           :                 |  一致性   |
                           :                 |  机构     |    +--------+
 +--------+    +--------+  :   +--------+    |           |    |        |
 |        |    |        |  :   |        |    |           |    |        |
 |  CPU   |    |  内存  |  :   | CPU    |    |           |---&amp;gt;|  设备  |
 |  核心  |---&amp;gt;|  请求  |-----&amp;gt;| Cache  |&amp;lt;--&amp;gt;|           |    |        |
 |        |    |  队列  |  :   |        |    |           |    |        |
 |        |    |        |  :   |        |    |           |    +--------+
 +--------+    +--------+  :   +--------+    +-----------+
                           :
                           :
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些LOAD和STORE可能不会实际出现在发起操作的CPU之外, 因为在CPU自己的cache上就能满足需要, 尽管如此, 如果其他CPU关心这些数据, 那么完整的内存访问还是会发生, 因为cache一致性机构将迁移相应的cache行到访问它的CPU, 使一致性得到传播.&lt;/p&gt;

&lt;p&gt;在保持程序所期望的上下文逻辑的前提下, CPU核心可能会按它认为合适的顺序来执行指令.&lt;br /&gt;
一些指令会产生LOAD和STORE操作, 并且将它们放到内存请求队列中, 等待被执行. &lt;br /&gt;
CPU核心可能会按它喜欢的顺序来将这些操作放进队列, 然后继续运行, 直到它必须等待这些访存指令完成的时候为止.&lt;/p&gt;

&lt;p&gt;内存屏障所需要关心的是访存操作从CPU一侧穿越到内存一侧的顺序, 和系统中的其他部件感知到的操作发生的顺序.&lt;/p&gt;

&lt;p&gt;对于一个CPU自己的LOAD和STORE来说, 并不需要使用内存屏障, 因为CPU总是能按程序执行顺序看到它们所执行的LOAD和STORE操作.&lt;/p&gt;

&lt;p&gt;MMIO或其他设备存取可能绕开cache系统. 这取决于访问设备所经过的内存窗口的属性和/或是否使用了CPU所特有的与设备进行交互的指令.&lt;/p&gt;

&lt;h3 id=&quot;cache&quot;&gt;CACHE一致性&lt;/h3&gt;

&lt;p&gt;但是, 事情并不是像上面所说的那样简单: 因为虽然可以期望cache是一致的, 但是一致性传播的顺序却是没有保证的. &lt;br /&gt;
也就是说, 虽然一个CPU所做出的更新将最终被其它CPU都看到, 但是却不保证其他CPU所看到的都是相同的顺序.&lt;/p&gt;

&lt;p&gt;考虑这样一个系统, 它具有双CPU(1和2), 每个CPU有一对并行的数据cache(CPU 1对应A/B, CPU 2对应C/D):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;             :
             :                          +--------+
             :      +---------+         |        |
 +--------+  : +---&amp;gt;| Cache A |&amp;lt;-------&amp;gt;|        |
 |        |  : |    +---------+         |        |
 |  CPU 1 |&amp;lt;---+                        |        |
 |        |  : |    +---------+         |        |
 +--------+  : +---&amp;gt;| Cache B |&amp;lt;-------&amp;gt;|        |
             :      +---------+         |        |
             :                          |  内存  |
             :      +---------+         |  系统  |
 +--------+  : +---&amp;gt;| Cache C |&amp;lt;-------&amp;gt;|        |
 |        |  : |    +---------+         |        |
 |  CPU 2 |&amp;lt;---+                        |        |
 |        |  : |    +---------+         |        |
 +--------+  : +---&amp;gt;| Cache D |&amp;lt;-------&amp;gt;|        |
             :      +---------+         |        |
             :                          +--------+
             :
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;想象一下该系统有如下属性:&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;) 一个奇数号的cache行可能被缓存在cache A, cache C, 或者可能依然驻留在内存中;&lt;br /&gt;
(&lt;/em&gt;) 一个偶数号的cache行可能被缓存在cache B, cache D, 或者可能依然驻留在内存中;&lt;br /&gt;
(&lt;em&gt;) 而当CPU核心访问一个cache时, 另一个cache可以同时利用总线来访问系统中的其他部分 - 可能是替换一个脏的cache行或者进行预取;&lt;br /&gt;
(&lt;/em&gt;) 每个cache都有一个操作队列, 被用于保持cache与系统中的其他部分的一致性;&lt;br /&gt;
(*) 当LOAD命中了已经存在于cache中的行时, 该一致性队列并不会得到冲刷, 尽管队列中的内容可能会影响这些LOAD操作. &lt;br /&gt;
    译注: 也就是说, 队列中有针对某一cache行的更新操作正在等待被执行, 而这时LOAD操作需要读这个cache行. &lt;br /&gt;
    这种情况下, LOAD并不会等待队列中的这个更新完成, 而是直接获取了更新前的值.&lt;/p&gt;

&lt;p&gt;接下来, 想象一下在第一个CPU上执行两个写操作, 并在它们之间使用一个写屏障, 以保证它们按要求的顺序到达该CPU的cache:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2           说明
=============== =============== =======================================
                                u == 0, v == 1 并且 p == &amp;amp;u, q == &amp;amp;u
v = 2;
smp_wmb();                      确保对v的修改先于对p的修改被感知
&amp;lt;A:modify v=2&amp;gt;                  v的值只存在于cache A中
p = &amp;amp;v;
&amp;lt;B:modify p=&amp;amp;v&amp;gt;                 p的值只存在于cache B中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;写内存屏障保证系统中的其他CPU会按正确的顺序看到本地CPU cache的更新. &lt;br /&gt;
但是设想一下第二个CPU要去读取这些值的情形:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2           说明
=============== =============== =======================================
...
                q = p;
                x = *q;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这一对读操作可能不会在预期的顺序下执行, 比如持有p的cache行可能被更新到另一个CPU的cache, 而持有v的cache行因为其他一些cache事件的影响而延迟了对那个CPU的cache的更新:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2           说明
=============== =============== =======================================
                                u == 0, v == 1 并且 p == &amp;amp;u, q == &amp;amp;u
v = 2;
smp_wmb();
&amp;lt;A:modify v=2&amp;gt;  &amp;lt;C:busy&amp;gt;
                &amp;lt;C:queue v=2&amp;gt;
p = &amp;amp;v;         q = p;
                &amp;lt;D:request p&amp;gt;
&amp;lt;B:modify p=&amp;amp;v&amp;gt; &amp;lt;D:commit p=&amp;amp;v&amp;gt;
                &amp;lt;D:read p&amp;gt;
                x = *q;
                &amp;lt;C:read *q&amp;gt;     在v被更新到cache之前读取v
                &amp;lt;C:unbusy&amp;gt;
                &amp;lt;C:commit v=2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上, 虽然最终CPU 2的两个cache行都将得到更新, 但是在没有干预的情况下, 并不能保证更新的顺序跟CPU 1提交的顺序一致.&lt;/p&gt;

&lt;p&gt;我们需要在两次LOAD之间插入一个数据依赖屏障或读屏障, 以作为干预. &lt;br /&gt;
这将强制cache在处理后续的请求之前, 先让它的一致性队列得到提交:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 1           CPU 2           说明
=============== =============== =======================================
                                u == 0, v == 1 并且 p == &amp;amp;u, q == &amp;amp;u
v = 2;
smp_wmb();
&amp;lt;A:modify v=2&amp;gt;  &amp;lt;C:busy&amp;gt;
                &amp;lt;C:queue v=2&amp;gt;
p = &amp;amp;v;         q = p;
                &amp;lt;D:request p&amp;gt;
&amp;lt;B:modify p=&amp;amp;v&amp;gt; &amp;lt;D:commit p=&amp;amp;v&amp;gt;
                &amp;lt;D:read p&amp;gt;
                smp_read_barrier_depends()
                &amp;lt;C:unbusy&amp;gt;
                &amp;lt;C:commit v=2&amp;gt;
                x = *q;
                &amp;lt;C:read *q&amp;gt;     在v被更新到cache之后读取v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些问题会在DEC Alpha处理器上遇到, 这些处理器使用了分列cache, 通过提高数据总线的利用率以提升性能. &lt;br /&gt;
虽然大部分的CPU在读操作依赖于读操作的时候, 会在第二个读操作中隐含一个数依赖屏障, 但是并不是所有CPU都这样, 因此不能依赖这一点.&lt;/p&gt;

&lt;p&gt;其他的CPU也可能使用分列cache, 但对于普通的内存访问, 他们会协调各个cache列. &lt;br /&gt;
而Alpha处理器的处理逻辑则取消了这样的协调动作, 除非使用内存屏障.&lt;/p&gt;

&lt;h3 id=&quot;cachedma&quot;&gt;cache一致性与DMA&lt;/h3&gt;

&lt;p&gt;对于进行DMA操作的设备, 并不是所有系统都保持它们的cache一致性. &lt;br /&gt;
在这种情况下, 准备进行DMA的设备可能从RAM得到陈旧的数据, 因为脏的cache行可能还驻留在各个CPU的cache中, 而尚未写回到RAM. &lt;br /&gt;
为了解决这个问题, 内核的相应部分必须将cache中重叠的数据冲刷掉(或者使它们失效)(译注: 冲刷掉cache中的相应内容, 以保持cache与RAM的一致).&lt;/p&gt;

&lt;p&gt;此外, 在设备已经通过DMA将数据写入RAM之后, 这些数据可能被cache写回RAM的脏的cache行所覆盖, 或者CPU已缓存的cache行可能直接掩盖了RAM被更新的事实&lt;br /&gt;
(译注: 使得对应的LOAD操作只能获得cache中的旧值, 而无法得到RAM中的新值), 直到cache行被从CPU cache中丢弃并且重新由RAM载入. &lt;br /&gt;
为解决这个问题, 内核的相应部分必须将cache中重叠的数据失效.&lt;/p&gt;

&lt;h3 id=&quot;cachemmio&quot;&gt;cache一致性与MMIO&lt;/h3&gt;

&lt;p&gt;内存映射IO通常通过内存地址来触发, 这些地址是CPU内存空间的某个窗口中的一部分, 而这个窗口相比于普通RAM对应的窗口会有着不同的属性.&lt;/p&gt;

&lt;p&gt;这些属性通常包含这样的情况: 访存会完全绕过cache, 而直接到达设备总线. &lt;br /&gt;
这意味着在效果上, MMIO可能超越先前发出的对被缓存内存的访问(译注: 意思是, MMIO后执行, 但是先到达内存; 而先执行的写内存操作则可能被缓存在cache上, 之后才能冲刷到内存). &lt;br /&gt;
这种情况下, 如果这两者有某种依赖的话, 使用一个内存屏障并不足够, 而需要在写被缓存内存和MMIO访存之间将cache冲刷掉.&lt;/p&gt;

&lt;h2 id=&quot;cpu-2&quot;&gt;CPU所能做到的&lt;/h2&gt;

&lt;p&gt;程序员可能会想当然地认为CPU将完全按照指定的顺序执行内存操作, 如果CPU是这样的话,比方说让它执行下面的代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = *A;
*B = b;
c = *C;
d = *D;
*E = e;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于每一条指令, 他们会期望CPU在完成内存操作之后, 才会去执行下一条指令, 于是系统中的其他组件将看到这样一个明确的操作序列:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOAD *A, STORE *B, LOAD *C, LOAD *D, STORE *E.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然, 实际情况是混乱的. 对于许多CPU和编译器来说, 上述假设不成立, 因为:&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;) LOAD操作可能更加需要立即完成以确保程序的执行速度(译注: 因为往往会有后续指令需要等待LOAD的结果), 而STORE操作推迟一下往往并不会有问题;&lt;br /&gt;
(&lt;/em&gt;) LOAD操作可以通过预取来完成, 并且在确认数据已经不需要之后, 预取结果可以丢弃;&lt;br /&gt;
(&lt;em&gt;) LOAD操作可以通过预取来完成, 导致结果被获取的时机可能并不符合期望的执行顺序;&lt;br /&gt;
(&lt;/em&gt;) 内存访问的顺序可能被重新排列, 以促进更好的使用CPU总线和cache;&lt;br /&gt;
(&lt;em&gt;) 有一些内存或IO设备支持对相邻地址的批量访问, 在跟它们打交道的时候, LOAD和STORE操作可能被合并, 从而削减访存事务建立的成本, 以提高性能(内存和PCI设备可能都可以这样做); &lt;br /&gt;
(&lt;/em&gt;) CPU的数据cache可能影响访问顺序, 尽管cache一致性机构可以缓解这个问题 - 一旦STORE操作命中了cache - 但并不能保证一致性将按顺序传播到其他CPU&lt;br /&gt;
    (译注: 如果STORE操作命中了cache, 那么被更新过的脏数据可能会在cache中停留一段时间, 而不会立刻冲刷到内存中);&lt;/p&gt;

&lt;p&gt;所以说, 另一个CPU可能将上面的代码看作是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOAD *A, ..., LOAD {*C,*D}, STORE *E, STORE *B
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;“LOAD {&lt;em&gt;C,&lt;/em&gt;D}”是一个合并的LOAD&lt;/p&gt;

&lt;p&gt;但是, CPU将保证自身的一致性: 它将按正确的顺序看到自己的内存操作, 而不需要使用内存屏障. 以下面的代码为例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U = *A;
*A = V;
*A = W;
X = *A;
*A = Y;
Z = *A;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设不存在外部的干扰, 那么可以肯定最终的结果一定是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U == the original value of *A
U == *A的初始值
X == W
Z == Y
*A == Y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于上面的代码, CPU可能产生的全部内存访问序列如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U=LOAD *A, STORE *A=V, STORE *A=W, X=LOAD *A, STORE *A=Y, Z=LOAD *A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然而, 对于这个序列, 如果没有干预, 在保证一致性的前提下, 序列中的一些操作也很可能会被合并或丢弃.&lt;/p&gt;

&lt;p&gt;在CPU看到这些操作之前, 编译器也可能会合并, 丢弃或推迟序列中的一些操作.&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = V;
*A = W;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可能削减为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = W;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是, 在没有使用写屏障的情况下, 可以认为将V写入*A的STORE操作丢失了. 类似的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = Y;
Z = *A;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在没有内存屏障的情况下, 可能削减为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*A = Y;
Z = Y;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是在该CPU之外, 根本就看不到有LOAD操作存在.&lt;/p&gt;

&lt;h3 id=&quot;alpha&quot;&gt;特别值得一提的Alpha处理器&lt;/h3&gt;

&lt;p&gt;DEC Alpha是现有的最为松散的CPU之一. &lt;br /&gt;
不仅如此, 许多版本的Alpha CPU拥有分列的数据cache, 允许他们在不同的时间更新两个语义相关的缓存. &lt;br /&gt;
因为内存一致性系统需要同步更新系统的两个cache, 数据依赖屏障在这里就真正成为了必要, 以使得CPU能够按正确的顺序来处理指针的更新和新数据的获取.&lt;/p&gt;

&lt;p&gt;Alpha处理器定义了Linux内核的内存屏障模型. (译注: 体系结构无关的代码需要以最坏情况为基准来考虑.)&lt;/p&gt;

&lt;h2 id=&quot;section-26&quot;&gt;使用示例&lt;/h2&gt;

&lt;h3 id=&quot;section-27&quot;&gt;环型缓冲区&lt;/h3&gt;

&lt;p&gt;内存屏障可以用于实现环型缓冲区, 不需要使用锁, 就能使生产者和消费者串行化. 参阅:&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>一致性hash基础知识(二)</title>
     <link href="http://localhost:4000/blog/2016/09/02/consistent-hashing-second.html"/>
     <updated>2016-09-02T20:45:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/09/02/consistent-hashing-second</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;在上一篇文章《&lt;a href=&quot;http://github.tiankonguse.com/blog/2016/08/21/consistent-hashing.html&quot;&gt;一致性hash基础知识&lt;/a&gt;》中记录了自己负责的缓存服务需要搞成分布式, 然后研究了一致性hash的理论知识.&lt;br /&gt;
后来讨论, 发现还有很多问题, 这里就一点一点的看看遇到的问题以及解决方案吧.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个服务是一个支持批量查询的资料系统。
用户请求的时候会带上N个资料的key以及M个资料的字段名，服务会返回N*M的资料信息。　&lt;/p&gt;

  &lt;p&gt;这里有三个维度的命中率：字段命中率，key命中率，请求命中率。
当然，其他人只关心请求命中率的。&lt;/p&gt;

  &lt;p&gt;假设一个请求有100个key和100个field,只要任意一个key的任意一个字段在cache中过期或未找到，请求命中率中就算未命中。
所以这里的请求命中率很低只有70~80%, 而key的命中率是80~90%, 字段的命中率是90~99.9%.&lt;/p&gt;

  &lt;p&gt;当然命中率低的根本原因并不是这个，所以这个功能并不能实质性解决命中率问题，不过加了这个在某些时候可以提供命中率，所以还是加上吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;固定路由&lt;/h2&gt;

&lt;p&gt;其实上篇提到的机器取模问题, 解决方案并不是只有一致性hash一个.&lt;br /&gt;
现在我们再来看看这个问题.&lt;/p&gt;

&lt;p&gt;原型: 请求的key hash到一个数字, 然后这个数字直接对机器数取模来决定路由到某台机器上.  &lt;br /&gt;
问题: 机器减少或增多, key与机器的关系会重映射, 瞬间命中率很低.&lt;/p&gt;

&lt;p&gt;上篇的解决方案是对机器也进行hash, 这样key和机器都是一系列数字, 然后我们定义一个规则:每个请求的key属于环上顺时针方向的第一个机器, 也就是第一个大于key的机器.&lt;/p&gt;

&lt;p&gt;再深入的看一致性hash这个方案, 其本质是它不是不取模了, 而是取模固定了, 比如是整数最大值.&lt;br /&gt;
当取模因子固定后, 再定一个策略把机器与key关联上即可.&lt;/p&gt;

&lt;p&gt;看到这里, 很容易得出结论: 解决这个问题的本质在于减少key与机器的重映射, 最常见的方案是取模因子固定.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PS: 当然, 如果取模因子变化了, 但是能保证key和机器的映射变化不大的话, 也是可以的. google有个算法就可以做到,这里就不深入讲解了.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;既然这样, 我们取一个相当大的取模因子即可, 比如一个很大的质数 10007.&lt;br /&gt;
然后定义一个区间来和机器关联上.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/4293974727.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们也可以得到一个key与机器的映射关系, 而且某个区间负载比较高了,我们调整这个区间与机器的关系即可.&lt;/p&gt;

&lt;p&gt;现在我们再来看看删除机器与增加机器的影响.&lt;/p&gt;

&lt;p&gt;增加机器时, 拆分某个区间, 拆除的新区间分给新机器.  只影响两个区间.&lt;br /&gt;
删除机器时, 直接把这个区间挂在其他机器下接口.  也是只影响两个区间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1576502651.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;静态路由唯一的缺点就是key与机器的关系是人工配置的, 维护成本高.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;业务面临的问题&lt;/h2&gt;

&lt;p&gt;不管是一致性hash, 还是静态路由, 我们都是直接把key映射到机器上. &lt;br /&gt;
但是我这个业务比较特殊: 请求有N个key, 经过映射请求将会扩散N倍, 流量也会翻一倍, 很多其他操作也被放大N倍, 好恐怖.&lt;/p&gt;

&lt;p&gt;背景中介绍了, 加上这个功能不能从根本上提高命中率, 所以命中率不变的, 这样再已扩散, 下层也撑不住了.&lt;br /&gt;
所以面临一个问题: 一个机器不能简单的当做一个节点了, 一个节点应该是一组机器, 然后我们需要固定的节点数, 即对机器分组.&lt;/p&gt;

&lt;p&gt;这个时候就需要维护N个节点与机器的关系了, 成本好高, 但是面对扩散问题, 只好选择维护成本高的固定节点这个方案了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/678097004.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;容灾问题&lt;/h2&gt;

&lt;p&gt;讨论一致性hash和静态路由的时候一直在说发现机器故障时, 把机器摘除; 机器灰度后, 把机器加进来.&lt;br /&gt;
那么我们如何知道机器故障了呢? 又是如何知道机器恢复了呢?&lt;/p&gt;

&lt;p&gt;其实这是一个很常见的容灾问题, 大部分公司应该都有非常成熟的容灾解决方案, 大概都是做一个下面这样的组件:&lt;/p&gt;

&lt;p&gt;有一个探测程序, 将探测业务机器的状况, 并将探测的结果统一上报到决策服务.&lt;br /&gt;
决策服务根据探测结果判断某台机器是否可用, 然后将机器的判断结果下发到业务机器中.&lt;br /&gt;
当然, 决策服务也可以是探测服务, 也可能就在业务机器中, 我们暂时不考虑这些细节, 只需要关心大的功能点.&lt;/p&gt;

&lt;p&gt;组件的大致架构大概如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3025383273.png&quot; alt=&quot;组件架构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个组件可以理解为服务与服务之间加的中间层, 用于解决服务间的耦合问题.&lt;br /&gt;
被调的服务挂了, 调用方无需感知的, 组件自动剔除故障机器; 机器恢复, 组件自动加入机器. 
当然, 这样的组件实现方式和架构千差万别, 但是目的是一样的, 就是解决容灾问题:  机器挂了对业务无影响, IDC挂了对业务无影响, 当然稍微复杂的还会根据机器的负载和流量还自动调度.&lt;/p&gt;

&lt;p&gt;这个一个组件自己短期内实现一个, 不容易保证高可用性, 所以自己的业务只能利用上已有的组件, 不能自己来实现这样的功能(即使实现了能够使用的阻力也很大吧).&lt;/p&gt;

&lt;p&gt;有人可能会问:以前的服务你们是怎么容灾的. &lt;br /&gt;
答案是使用公司已经的负载均衡组件, 大家可以google &lt;a href=&quot;https://www.google.com.hk/#newwindow=1&amp;amp;safe=strict&amp;amp;q=tencent+l5&quot;&gt;tencent l5&lt;/a&gt; 了解组件细节.&lt;/p&gt;

&lt;p&gt;我们在业务面临的问题中提到, 我们不能简单的建立key和机器的映射, 而需要建立key和分组节点的映射, 刚好我们每一个分组节点都可以单独来容灾. 可谓是分组和容灾完美结合了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2772322102.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候总体来看看我们的解决方案:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对机器进行节点分组, 每个节点自身保证容灾问题.&lt;/li&gt;
  &lt;li&gt;使用静态路由表对分组节点建立映射&lt;/li&gt;
  &lt;li&gt;请求的key hash 取模后, 可以根据路由表找到分组节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样对现有业务的影响也不少:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上了分布式功能(N节点),  每个节点只需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;1/N&lt;/code&gt;的数据, 可以显著提高本地命中率, 减少远程cache的访问&lt;/li&gt;
  &lt;li&gt;对于N节点系统来说, 请求被放大了N倍, 流量会增加N倍, CPU也会适当增加.&lt;/li&gt;
  &lt;li&gt;由于总体命中率并没有提高, 但是请求扩散, 所以对下层的访问也会扩大N倍.&lt;/li&gt;
  &lt;li&gt;由于节点内为了容灾, 往往会加入不同IDC的机器, 这样一个请求路由到多个节点后, 可能面临流量在不同IDC之间传输可能会增大服务平均延时的问题.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好吧, 短期内上线这个功能的弊大于利, 因为现在系统的瓶颈在CPU, 增加这个功能消耗更多的CPU了, 所以还是先增加个开关先关闭这个功能吧.&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>神器strace, ltrace</title>
     <link href="http://localhost:4000/blog/2016/08/28/strace.html"/>
     <updated>2016-08-28T20:31:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/28/strace</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;strace主要用于跟踪系统调用和信号。&lt;br /&gt;
ltrace用于跟踪用户级别的函数。&lt;/p&gt;

&lt;p&gt;可以解决的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查看哪些系统调用负载较高&lt;/li&gt;
  &lt;li&gt;查看系统调用耗时&lt;/li&gt;
  &lt;li&gt;定位一些疑难杂症问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;strace&quot;&gt;系统调用 strace&lt;/h2&gt;

&lt;p&gt;如果你直接strace一个进程，你会发现被输出刷屏了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace -p &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;统计&lt;/h3&gt;

&lt;p&gt;如果是性能问题，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;参数统计一下系统调用耗时。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strace -cp &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如下图，统计一会按&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-c&lt;/code&gt;退出统计，可以看到各个系统调用的耗时。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo strace -cp 6377
Process 6377 attached

% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 59.85    0.000787           2       389       377 recvmsg
 19.54    0.000257           2       126           poll
 15.29    0.000201           3        72           write
  3.42    0.000045           1        38           read
  1.14    0.000015           3         6           writev
  0.76    0.000010          10         1           restart_syscall
------ ----------- ----------- --------- --------- ----------------
100.00    0.001315                   632       377 total
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;跟踪系统调用&lt;/h3&gt;

&lt;p&gt;看到一个系统调用比较耗时时，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt;参数只看这个系统调用在干什么的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo strace -p 6377 -e recvmsg
Process 6377 attached
recvmsg(16, 0x7fffb7b53160, 0)          = -1 EAGAIN (Resource temporarily unavailable)
recvmsg(11, 0x7fffb7b53120, 0)          = -1 EAGAIN (Resource temporarily unavailable)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;时间参数&lt;/h3&gt;

&lt;p&gt;上面展示系统调用了，但是没有显示时间。&lt;br /&gt;
写一个服务或者程序，系统调用异常了往往就是io操作，所以我们需要看看读与写的时间，来看看耗时是否合理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt; 显示时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-tt&lt;/code&gt; 显示时间和微秒&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ttt&lt;/code&gt; 显示时间戳和微妙&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-T&lt;/code&gt; 显示系统调用耗时&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt; 输出每个系统调用的耗时&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -t
21:32:36 select(14, [3 4 5 6 10 11 13], [], NULL, NULL) = 1 (in [10])
21:32:39 read(10, &quot;\27\3\3\0\220\0\0\0\0\0\0\0(P\n\2q\214\n7\331\354F\237U\233\355\357\vP\334\247&quot;..., 16384) = 195

# -tt
21:33:43.202679 select(11, [3 4 5 6 10], [], NULL, NULL) = 1 (in [10])
21:33:44.755529 read(10, &quot;\27\3\3\0\220\0\0\0\0\0\0\0003jPn@\272\263\256&amp;amp;7\1\350\3171K\375V~P.&quot;..., 16384) = 149d

# -ttt
1472391251.664652 select(11, [3 4 5 6 10], [], NULL, NULL) = 1 (in [10])
1472391254.052413 read(10, &quot;\27\3\3\0\220\0\0\0\0\0\0\0007\203\334\253I\325\232\216\31\212\207y\35x\263*\317\235\272\242&quot;..., 16384) = 195

# -T
select(11, [3 4 5 6 10], [], NULL, NULL) = 1 (in [10]) &amp;lt;3.643800&amp;gt;
read(10, &quot;\27\3\3\0\220\0\0\0\0\0\0\0:\271\330\241H-\34\202\222\261\221|\267\233Z\311\315b\353/&quot;..., 16384) = 195 &amp;lt;0.000098&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;多进程与多线程&lt;/h2&gt;

&lt;p&gt;如果我们的程序是多进程和多线程时，我们希望strace所有进程，　此时可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo strace -p 7542 -T -ttt -f
Process 7542 attached with 9 threads
[pid  9462] 1472391845.939746 restart_syscall(&amp;lt;... resuming interrupted call ...&amp;gt; &amp;lt;unfinished ...&amp;gt;
[pid  7561] 1472391845.939766 futex(0x7f99b49feab4, FUTEX_WAIT_PRIVATE, 1, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7554] 1472391845.939785 futex(0x7f99b97beab4, FUTEX_WAIT_PRIVATE, 1, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7549] 1472391845.939808 futex(0x7f99ba03f864, FUTEX_WAIT_PRIVATE, 1, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7548] 1472391845.939822 futex(0x3ed20538a764, FUTEX_WAIT_PRIVATE, 4025, NULL) = -1 EAGAIN (Resource temporarily unavailable) &amp;lt;0.000007&amp;gt;
[pid  7547] 1472391845.939855 futex(0x3ed20538a764, FUTEX_WAIT_PRIVATE, 4026, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7548] 1472391845.939869 futex(0x3ed20538a764, FUTEX_WAIT_PRIVATE, 4026, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7546] 1472391845.939894 futex(0x7f99bb89aab4, FUTEX_WAIT_PRIVATE, 1, NULL &amp;lt;unfinished ...&amp;gt;
[pid  7545] 1472391845.939906 epoll_wait(12,  &amp;lt;unfinished ...&amp;gt;
[pid  7542] 1472391845.939935 restart_syscall(&amp;lt;... resuming interrupted call ...&amp;gt;) = -1 ETIMEDOUT (Connection timed out) &amp;lt;0.550624&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;输出&lt;/h3&gt;

&lt;p&gt;一般对于strace输出可以直接重定向到文件，但是这里也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-o file&lt;/code&gt;参数把内容输出到文件，然后慢慢分析或者使用其他命令进一步分析。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是不是发现直接使用重定向没有得到内容，　这个说明strace的输出不是标准输出。&lt;br /&gt;
所以我们需要把标准错误输出也重定向到标准输出就行了。&lt;br /&gt;
命令: &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有时候我们想直接在strace中看系统调用时传输的数据，比如文本形式的日志数据或者http数据。&lt;br /&gt;
但是我们又会发现输出的内容比较少，这个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-s　strsize&lt;/code&gt;参数可以调整输出的buf大小。&lt;/p&gt;

&lt;h2 id=&quot;ltrace&quot;&gt;用户函数 ltrace&lt;/h2&gt;

&lt;p&gt;ltrace和strace就是个兄弟命令，用法几乎都一样。&lt;br /&gt;
这里只记录一下不同点。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;系统调用&lt;/h3&gt;

&lt;p&gt;是的，这个命令也可以查看系统调用，只需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;-S&lt;/code&gt;参数。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;经验&lt;/h2&gt;

&lt;h3 id=&quot;section-8&quot;&gt;退出&lt;/h3&gt;

&lt;p&gt;默认会一直追踪进程，需要手动退出。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;默认输出&lt;/h3&gt;

&lt;p&gt;默认输出的含义是每个系统调用的函数名，参数和返回值，并且输出是标准错误输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; open(&quot;/dev/null&quot;, O_RDONLY) = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;系统调用失败&lt;/h3&gt;

&lt;p&gt;系统调用发生错误是通常是-1, 然后errno被设置为对应的错误码。&lt;br /&gt;
所以strace的时候会显示错误码和错误信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open(&quot;/foo/bar&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;信号&lt;/h3&gt;

&lt;p&gt;对于信号，会输出信号符号和信号信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sigsuspend([] &amp;lt;unfinished ...&amp;gt;
--- SIGINT (Interrupt) ---
+++ killed by SIGINT +++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-12&quot;&gt;未完成系统调用&lt;/h3&gt;

&lt;p&gt;有时候系统调用需要花费一下时间，所以返回值和耗时是没办法统计到的。所以输出分两个阶段。&lt;br /&gt;
第一阶段会标识为&lt;code class=&quot;highlighter-rouge&quot;&gt;unfinished&lt;/code&gt;, 第二阶段会标识为&lt;code class=&quot;highlighter-rouge&quot;&gt;resumed&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[pid 28772] select(4, [3], NULL, NULL, NULL &amp;lt;unfinished ...&amp;gt;
[pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0
[pid 28772] &amp;lt;... select resumed&amp;gt; )      = 1 (in [3])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-13&quot;&gt;位相关参数&lt;/h3&gt;

&lt;p&gt;第二个和第三个参数一个是位或的形式，　一个是经典的八进制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open(&quot;xyzzy&quot;, O_WRONLY|O_APPEND|O_CREAT, 0666) = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-14&quot;&gt;复杂结构参数&lt;/h3&gt;

&lt;p&gt;对于结构体，即使是指针，也把对应的内容以文本的形式输出了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lstat(&quot;/dev/null&quot;, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>一致性hash基础知识</title>
     <link href="http://localhost:4000/blog/2016/08/21/consistent-hashing.html"/>
     <updated>2016-08-21T15:31:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/21/consistent-hashing</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;有一个数据统一输出服务，由于超时率原来越高，要我增加了一层cache。
但是由于底层数据量比较大(千万级别)，每个数据的资料也很多（几百个），每个数据的资料大小也很大(几字节到几十k不等)，请求的数据又是两级放大的，请求还比较分散，导致单机cache命中率不是很理想。
于是准备改造成一致性hash,提高单机命中率。
这里简单的记录一下一致性hash的基础知识。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个服务是一个支持批量查询的资料系统。
用户请求的时候会带上N个资料的key以及M个资料的字段名，服务会返回N*M的资料信息。　&lt;/p&gt;

  &lt;p&gt;这里有三个维度的命中率：字段命中率，key命中率，请求命中率。
当然，其他人只关心请求命中率的。&lt;/p&gt;

  &lt;p&gt;假设请求有100个key和100个field,只要任意一个key的任意一个字段在cache中过期或未找到，请求命中率中就算未命中。
所以这里的请求命中率很低只有70~80%, 而key的命中率是80~90%, 字段的命中率是90~99.9%.&lt;/p&gt;

  &lt;p&gt;当然命中率低的根本原因并不是这个，所以这个功能并不能实质性解决命中率问题，不过加了这个肯定可以提供命中率，所以还是加上吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;理论知识&lt;/h2&gt;

&lt;p&gt;一致性hash的思想早在1997年就由MIT的Karger及其合作者提出来了,目标是解决互联网中热点问题(缓存问题)。&lt;br /&gt;
当时还有一篇论文，叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;Web Caching with Consistent Hashing&lt;/code&gt;, 大家可以看看（下面参考文献有链接）。&lt;/p&gt;

&lt;p&gt;一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;平衡性(Balance)：哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。&lt;/li&gt;
  &lt;li&gt;单调性(Monotonicity)：如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。&lt;br /&gt;
哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。&lt;/li&gt;
  &lt;li&gt;分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。&lt;br /&gt;
当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。&lt;br /&gt;
这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。&lt;br /&gt;
分散性的定义就是上述情况发生的严重程度。&lt;br /&gt;
好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/li&gt;
  &lt;li&gt;负载(Load)：负载问题实际上是从另一个角度看待分散性问题。&lt;br /&gt;
既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。&lt;br /&gt;
与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hash&quot;&gt;基本hash的问题&lt;/h2&gt;

&lt;p&gt;基本的hash是对请求的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;映射到一个数字，然后对机器数取模。这样就知道该请求去那台机器加载数据了。&lt;/p&gt;

&lt;p&gt;假设机器数量不变的话，这种做法勉强还可以接受。虽然取模时请求分布可能不均匀，取决与机器数量。&lt;br /&gt;
但是当我们增加或减少机器数量时，　面临一个问题：取模因子变化了。&lt;br /&gt;
影响很严重，key映射的机器会全部变化。结果是这个时间大部分请求会不能cache住数据，透传率会突然增高，下层可能被压死。&lt;/p&gt;

&lt;h2 id=&quot;hash-1&quot;&gt;拓展基本hash&lt;/h2&gt;

&lt;p&gt;看到上面的问题，我们第一个能想到的是不能直接取模了。&lt;br /&gt;
我们改变机器时，要尽可能的不变更机器与key的对应关系。&lt;/p&gt;

&lt;p&gt;此时我们要做的是中间加一层映射。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;增加一层－环&lt;/h3&gt;

&lt;p&gt;这个环也不需要取模了，直接是&lt;code class=&quot;highlighter-rouge&quot;&gt;0~(2^32)-1&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/407113551.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;key&quot;&gt;key映射到环上&lt;/h3&gt;

&lt;p&gt;我们把请求的key映射到环上。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hashKey(object1) = key1;
hashKey(object2) = key2;
hashKey(object3) = key3;
hashKey(object4) = key4;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/759708473.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;机器映射到环上&lt;/h3&gt;

&lt;p&gt;我们把机器也全部映射到环上。&lt;br /&gt;
我们定义每个请求的key属于环上顺时针方向的第一个机器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HashIp(cache A&quot;192.168.1.2&quot;) = key A;
HashIp(cache B&quot;192.168.1.3&quot;) = key B;
HashIp(cache C&quot;192.168.1.4&quot;) = key C;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/493472709.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;机器的删除&lt;/h3&gt;

&lt;p&gt;假设我们删除了机器&lt;code class=&quot;highlighter-rouge&quot;&gt;cache B&lt;/code&gt;,那么&lt;code class=&quot;highlighter-rouge&quot;&gt;cache B&lt;/code&gt;区间的key肯定会受影响的。&lt;br /&gt;
按照我们上面的定义，&lt;code class=&quot;highlighter-rouge&quot;&gt;cache B&lt;/code&gt;区间的key会属于顺时针方向第一个机器，即&lt;code class=&quot;highlighter-rouge&quot;&gt;cache C&lt;/code&gt;.&lt;br /&gt;
此时其他区间的key都没有受到影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/748974764.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;机器的增加&lt;/h3&gt;

&lt;p&gt;假设我们增加了机器&lt;code class=&quot;highlighter-rouge&quot;&gt;cache D&lt;/code&gt;,且在&lt;code class=&quot;highlighter-rouge&quot;&gt;cache B&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cache C&lt;/code&gt;之间。&lt;br /&gt;
则&lt;code class=&quot;highlighter-rouge&quot;&gt;cache D&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache B&lt;/code&gt;之间的key肯定会受影响。&lt;br /&gt;
按照我们上面的定义，　这个区间的key会属于&lt;code class=&quot;highlighter-rouge&quot;&gt;cache D&lt;/code&gt;。&lt;br /&gt;
此时其他区间的key依旧都没有受到影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1279050431.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;加一层的缺点&lt;/h3&gt;

&lt;p&gt;我们通过加一层来解决了单调性和负载均衡的问题，但是还有一个问题无法避免：缺少平衡性。&lt;/p&gt;

&lt;p&gt;我们把整个区间划分为机器数相等的区间个数。&lt;br /&gt;
这样如果某个区间的key特别多的话，那个区间的机器压力就会很大。&lt;br /&gt;
这个是很常见的热key问题。&lt;/p&gt;

&lt;p&gt;针对这个问题我们暂时没有办法完全避免，但是我们可以减小这个问题的概率：再增加一层虚拟节点&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;增加第二层-虚拟节点&lt;/h3&gt;

&lt;p&gt;上面提到，只增加一层环存在热点问题，于是我们需要再增加一层虚拟节点来较少热点的概率。&lt;br /&gt;
虚拟节点的含义是一个机器不是划分一个大的区间，而是划分很多小的区间。&lt;/p&gt;

&lt;p&gt;比如我们对hash的机器增加一个编号后缀。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HashIp(cache A&quot;192.168.1.2?1&quot;); =&amp;gt; key A1
HashIp(cache A&quot;192.168.1.2?2&quot;); =&amp;gt; key A2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;增加虚拟阶段后，　映射大概如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2266440355.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于机器虚拟节点多了，　环上就把区间划分为更小的片段了，　这样就大大降低了区间热点的概率了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3742381162.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C&quot;&gt;维基百科：一致哈希&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www8.org/w8-papers/2a-webserver/caching/paper2.html&quot;&gt;论文：Web Caching with Consistent Hashing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/56138/Consistent-hashing&quot;&gt;Consistent hashing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/cywosp/article/details/23397179&quot;&gt;一致性哈希算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/consistent-hashing.html&quot;&gt;一致性哈希算法及其在分布式系统中的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
    
   <entry>
     <title>http chunked包记录</title>
     <link href="http://localhost:4000/blog/2016/08/17/http-chunked.html"/>
     <updated>2016-08-17T21:31:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/17/http-chunked</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;http协议是一种文本协议, 文本协议有一个先天优势: 容易理解,容易阅读.&lt;br /&gt;
之前使用http协议的时候, 收到的包都有&lt;code class=&quot;highlighter-rouge&quot;&gt;Conent-Length&lt;/code&gt;, 所以判断包是否收完直接判断长度即可.&lt;br /&gt;
今天同事说自己http包解包后有问题, 于是帮忙看了一下, 发现是chunked包, &lt;a href=&quot;http://github.tiankonguse.com/blog/2016/08/13/tcpdump.html&quot;&gt;tcpdump&lt;/a&gt;抓包之后发现包被分片了.&lt;br /&gt;
这里了解一下chunked包, 顺便记录下业务该怎么处理chunked包.&lt;/p&gt;

&lt;p&gt;首先看一个知识点, 首先去&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.6.1&quot;&gt;RFC&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Chunked_transfer_encoding&quot;&gt;维基百科&lt;/a&gt;看看.&lt;br /&gt;
看完实际上就可以不用看我这篇文章了, 那上面写的比我这详细多了.&lt;br /&gt;
但是为了自己后续快速回顾知识点, 这里还是记录一下.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安全性前提&lt;/h2&gt;

&lt;p&gt;一般http的包头很小, 所以很多人都会假设包头肯定在第一个tcp包头.&lt;br /&gt;
这样其实是不合理的,我们应该按照http的协议来找包头.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool checkCompleteHttpHead(const char *buf,int len){
    if(strnstr(buf, &quot;\r\n\r\n&quot;, len) == NULL){   
        return 0; 
    }else{
        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;content-length&quot;&gt;Content-Length&lt;/h2&gt;

&lt;p&gt;在有&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;的时候, 我们只需要找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;, 然后就可以计算出包长了.&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;类型的包是一个包体连续的包, 所以直接取自己的数据即可.&lt;br /&gt;
比如我们返回的数据都是json, 所以一般都是直接去json数据.当然标准的做法应该是分析包头,得到包头和包体.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;当然上面的方法是错误的, 我们应该选分析包头, 是否正确的返回数据.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;transfer-encoding&quot;&gt;Transfer-Encoding&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Transfer-Encoding&lt;/code&gt;是chunked的包是http的另一种数据传输机制, 当网络传输的时候, 可能会进行分片, 每个片头会记录每个分片的大小.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。&lt;/li&gt;
  &lt;li&gt;每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。&lt;/li&gt;
  &lt;li&gt;最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。&lt;/li&gt;
  &lt;li&gt;消息最后以CRLF结尾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;样例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk
1C
and this is the second one
3
con
8
sequence
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###检查包完整性&lt;/p&gt;

&lt;p&gt;根据上面的协议, 最后一个分片是&lt;code class=&quot;highlighter-rouge&quot;&gt;0\r\n\r\n&lt;/code&gt;, 所以我们可以检查是否有这个字符串来判断是都得到完整的包.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(!strncmp(pEnd,&quot;0\r\n\r\n&quot;,5)){
    return len;
}else{
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;应用&lt;/h3&gt;

&lt;p&gt;这种方式的包对于我们应用来说, 其实有点麻烦的.&lt;br /&gt;
收到一个http包后, 我们需要解析包, 而不能像&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;那样直接find包体的前缀和后缀来得到自己想要的数据啦. &lt;br /&gt;
这时候我们需要处理chunked包, 去掉多余的分片标示的相关字符.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string strHttpRsp = &quot;&quot;, strRspBody = &quot;&quot;;

//填充http包到string, 回包是个json
strHttpRsp.assign(data, len);

string::size_type stPos = strHttpRsp.find_first_of('{');
if (stPos == string::npos) {
    return -__LINE__;
}

string::size_type stEndPos;

//去掉包体中 &quot;\r\n1500\r\n&quot; 这样的字符
while (stPos &amp;lt; strHttpRsp.length()) { 
    stEndPos = strHttpRsp.find(&quot;\r\n&quot;, stPos);
    if (stEndPos == string::npos || strHttpRsp.length() &amp;lt;= stEndPos + 2) {
        //最后一行
        strRspBody += strHttpRsp.substr(stPos);
        break;
    } else {
        //找到下一个字节数前面的\r\n
        strRspBody += strHttpRsp.substr(stPos, stEndPos - stPos);
        
        //跳过字节数
        stPos = strHttpRsp.find(&quot;\r\n&quot;, stEndPos + 2);
        if (stPos != string::npos &amp;amp;&amp;amp; stPos &amp;lt; strHttpRsp.length() - 2) {
        //跳过字节数后面的\r\n
            stPos += 2;
        } else {
            break;
        }
    }
}

stEndPos = strHttpRsp.find_last_of('}');
if (stEndPos == string::npos){
    return -__LINE__;
}
strHttpResponse = strRspBody.substr(0, stEndPos + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>lsof命令详解</title>
     <link href="http://localhost:4000/blog/2016/08/14/command-lsof.html"/>
     <updated>2016-08-14T13:48:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/14/command-lsof</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt;全名&lt;code class=&quot;highlighter-rouge&quot;&gt;list open files&lt;/code&gt;,含义为显示打开的文件列表．&lt;br /&gt;
我们都是知道，在linux的世界里，所有的事物都是文件，　对事物的操作就是对文件的操作．&lt;br /&gt;
比如设备是文件，目录是文件，socket是文件．我们通过lsof命令可以得到很多有用的信息．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ lsof -i -n
COMMAND   PID        USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ssh      3860 tiankonguse    3u  IPv4 277226      0t0  TCP 192.168.31.137:55470-&amp;gt;52.175.36.207:ssh (ESTABLISHED)
ssh      3860 tiankonguse    4u  IPv6 277256      0t0  TCP [::1]:7070 (LISTEN)
ssh      3860 tiankonguse    5u  IPv4 277257      0t0  TCP 127.0.0.1:7070 (LISTEN)
ssh      3860 tiankonguse    9u  IPv4 392596      0t0  TCP 127.0.0.1:7070-&amp;gt;127.0.0.1:47308 (CLOSE_WAIT)
ssh      3860 tiankonguse   10u  IPv4 425556      0t0  TCP 127.0.0.1:7070-&amp;gt;127.0.0.1:47424 (ESTABLISHED)
ssh      3860 tiankonguse   11u  IPv4 474716      0t0  TCP 127.0.0.1:7070-&amp;gt;127.0.0.1:47436 (ESTABLISHED)
chrome  31615 tiankonguse  102u  IPv4 474141      0t0  TCP 192.168.31.137:54857-&amp;gt;220.181.76.72:http (CLOSE_WAIT)
chrome  31615 tiankonguse  103u  IPv4 424629      0t0  TCP 127.0.0.1:47424-&amp;gt;127.0.0.1:7070 (ESTABLISHED)
chrome  31615 tiankonguse  104u  IPv4 432692      0t0  TCP 192.168.31.137:36335-&amp;gt;203.208.50.175:https (ESTABLISHED)
chrome  31615 tiankonguse  106u  IPv4 476207      0t0  TCP 127.0.0.1:47436-&amp;gt;127.0.0.1:7070 (ESTABLISHED)
chrome  31615 tiankonguse  111u  IPv4 273013      0t0  UDP *:mdns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;字段介绍&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt;默认显示字段有&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;含义如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMAND&lt;/code&gt; 程序命令,默认以9个字符长度显示的命令名称。可使用+c参数指定显示的宽度，若+c后跟的参数为零，则显示命令的全名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PID&lt;/code&gt; 进程id&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PPID&lt;/code&gt; 父进程的IP号，默认不显示，当使用-R参数可打开。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PGID&lt;/code&gt; 进程组的ID编号，默认也不会显示，当使用-g参数时可打开。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;USER&lt;/code&gt; 命令的执行UID或系统中登陆的用户名称。默认显示为用户名，当使用-l参数时，可显示UID。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FD&lt;/code&gt; 文件描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TYPE&lt;/code&gt; IPv4的包,IPv6包，DIR 目录，LINK 链接文件等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DEVICE&lt;/code&gt; 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;character special&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;block special&lt;/code&gt;表示的设备号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIZE/OFF&lt;/code&gt; 文件的大小，如果不能用大小表示的，会留空。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;参数控制。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NODE&lt;/code&gt; 本地文件的node码，或者协议，如TCP等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NAME&lt;/code&gt; 挂载点和文件的全路径（链接会被解析为实际路径），或者连接双方的地址和端口、状态等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;查看端口&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ lsof -i :80
COMMAND   PID        USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
chrome  31615 tiankonguse  102u  IPv4 537284      0t0  TCP 192.168.31.137:41976-&amp;gt;117.79.92.146:http (CLOSE_WAIT)
chrome  31615 tiankonguse  104u  IPv4 539670      0t0  TCP 192.168.31.137:34899-&amp;gt;151.101.16.133:http (ESTABLISHED)
chrome  31615 tiankonguse  105u  IPv4 539781      0t0  TCP 192.168.31.137:60814-&amp;gt;93-46-8-89.ip105.fastwebnet.it:http (SYN_SENT)
chrome  31615 tiankonguse  118u  IPv4 537818      0t0  TCP 192.168.31.137:34900-&amp;gt;151.101.16.133:http (ESTABLISHED)
chrome  31615 tiankonguse  122u  IPv4 537900      0t0  TCP 192.168.31.137:60815-&amp;gt;93-46-8-89.ip105.fastwebnet.it:http (SYN_SENT)
chrome  31615 tiankonguse  124u  IPv4 538905      0t0  TCP 192.168.31.137:41978-&amp;gt;117.79.92.146:http (CLOSE_WAIT)
chrome  31615 tiankonguse  128u  IPv4 538906      0t0  TCP 192.168.31.137:41979-&amp;gt;117.79.92.146:http (CLOSE_WAIT)
chrome  31615 tiankonguse  155u  IPv4 539020      0t0  TCP 192.168.31.137:34901-&amp;gt;151.101.16.133:http (ESTABLISHED)
chrome  31615 tiankonguse  170u  IPv4 539036      0t0  TCP 192.168.31.137:58368-&amp;gt;220.181.7.190:http (CLOSE_WAIT)
chrome  31615 tiankonguse  174u  IPv4 539021      0t0  TCP 192.168.31.137:34902-&amp;gt;151.101.16.133:http (ESTABLISHED)
chrome  31615 tiankonguse  183u  IPv4 539022      0t0  TCP 192.168.31.137:34903-&amp;gt;151.101.16.133:http (ESTABLISHED)
chrome  31615 tiankonguse  184u  IPv4 539023      0t0  TCP 192.168.31.137:34904-&amp;gt;151.101.16.133:http (ESTABLISHED)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;查看进程名&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ lsof -c chrome | more
lsof: WARNING: can't stat() ext4 file system /var/lib/docker/aufs
      Output information may be incomplete.
COMMAND   PID        USER   FD      TYPE             DEVICE SIZE/OFF     NODE NAME
chrome   1880 tiankonguse  cwd       DIR                0,3        0    24098 /proc/31953/fdinfo
chrome   1880 tiankonguse  rtd       DIR                0,3        0    24098 /proc/31953/fdinfo
chrome   1880 tiankonguse  txt       REG                8,2 99609936 24248328 /opt/google/chrome/chrome
chrome   1880 tiankonguse  DEL       REG               0,21             52587 /run/shm/.com.google.Chrome.SE37st
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;查看进程号&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ lsof -p 2127
lsof: WARNING: can't stat() ext4 file system /var/lib/docker/aufs
      Output information may be incomplete.
COMMAND  PID USER   FD      TYPE DEVICE SIZE/OFF NODE NAME
apache2 2127 root  cwd   unknown                      /proc/2127/cwd (readlink: Permission denied)
apache2 2127 root  rtd   unknown                      /proc/2127/root (readlink: Permission denied)
apache2 2127 root  txt   unknown                      /proc/2127/exe (readlink: Permission denied)
apache2 2127 root NOFD                                /proc/2127/fd (opendir: Permission denied)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;查看进程组&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ lsof -g 2127
lsof: WARNING: can't stat() ext4 file system /var/lib/docker/aufs
      Output information may be incomplete.
COMMAND  PID PGID     USER   FD      TYPE DEVICE SIZE/OFF NODE NAME
apache2 2127 2127     root  cwd   unknown                      /proc/2127/cwd (readlink: Permission denied)
apache2 2127 2127     root  rtd   unknown                      /proc/2127/root (readlink: Permission denied)
apache2 2127 2127     root  txt   unknown                      /proc/2127/exe (readlink: Permission denied)
apache2 2127 2127     root NOFD                                /proc/2127/fd (opendir: Permission denied)
apache2 2156 2127 www-data  cwd   unknown                      /proc/2156/cwd (readlink: Permission denied)
apache2 2156 2127 www-data  rtd   unknown                      /proc/2156/root (readlink: Permission denied)
apache2 2156 2127 www-data  txt   unknown                      /proc/2156/exe (readlink: Permission denied)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;查看目录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lsof +D /home/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;万能的其他&lt;/h3&gt;

&lt;p&gt;grep搜索，　如找到那些被删除但是没释放的文件．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lsof | grep xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>free命令详解</title>
     <link href="http://localhost:4000/blog/2016/08/14/command-free.html"/>
     <updated>2016-08-14T13:08:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/14/command-free</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;free命令是linux下最常见的命令之一．&lt;br /&gt;
这里简单记录一下．&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;用于显示系统内存的使用情况．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ free -m
             total       used       free     shared    buffers     cached
Mem:          3876       3549        326        323         24       1033
-/+ buffers/cache:       2491       1384
Swap:         4018        132       3886
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二行显示了从系统角度看来内存使用的情况．&lt;br /&gt;
第三行从用户角度显示内存信息,可用内存从数量上等于mem行used列值减去buffers和cached内存的大小．&lt;br /&gt;
第四行内存交换：　当可用内存少于额定值的时候，就会开始进行交换&lt;br /&gt;
这些信息都是从&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/meminfo&lt;/code&gt;读到的．&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;字段含义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;total 系统可用的内存大小, 数量上等于系统物理内存减去内核保留的内存&lt;/li&gt;
  &lt;li&gt;used 已经使用的内存数&lt;/li&gt;
  &lt;li&gt;free 空闲的内存数&lt;/li&gt;
  &lt;li&gt;shared 当前已经废弃不用&lt;/li&gt;
  &lt;li&gt;buffers: Buffer Cache内存数, 与某个块设备关联, 包含了文件系统元数据, 并且跟踪了块的变化&lt;/li&gt;
  &lt;li&gt;cached: Page Cache内存数,只包含了文件本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;缓存扩展&lt;/h3&gt;

&lt;p&gt;为了提高磁盘存取效率, Linux做了一些精心的设计, 除了对dentry进行缓存(用于VFS,加速文件路径名到inode的转换), 还采取了两种主要Cache方式：Buffer Cache和Page Cache。&lt;br /&gt;
前者针对磁盘块的读写，后者针对文件inode的读写。&lt;br /&gt;
这些Cache有效缩短了 I/O系统调用(如read,write,getdents)的时间。&lt;/p&gt;

&lt;p&gt;因为Linux会将暂时不使用的内存作为文件和数据缓存，以提高系统性能，当应用程序需要这些内存时，系统会自动释放.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;使用&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;大小&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt; B为单位&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-k&lt;/code&gt;　K为单位&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt; M为单位&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt; G为单位&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; 自动按合适的单位显示&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;按指定时间显示一次内容.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;显示指定数量次数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ free -m -c 3 -s 1
             total       used       free     shared    buffers     cached
Mem:          3876       3589        286        364         29       1085
-/+ buffers/cache:       2474       1401
Swap:         4018        132       3886

             total       used       free     shared    buffers     cached
Mem:          3876       3590        285        364         29       1086
-/+ buffers/cache:       2474       1401
Swap:         4018        132       3886

             total       used       free     shared    buffers     cached
Mem:          3876       3590        285        364         29       1086
-/+ buffers/cache:       2475       1401
Swap:         4018        132       3886
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>tcpdump命令详解</title>
     <link href="http://localhost:4000/blog/2016/08/13/tcpdump.html"/>
     <updated>2016-08-13T21:08:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/13/tcpdump</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;工作两年来使用了无数次tcpdump,但是还是不熟悉很多参数，现在详细记录一下．&lt;br /&gt;
具体参数请参考&lt;code class=&quot;highlighter-rouge&quot;&gt;man tcpdump&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;我们如果直接使用 tcpdump, 会抓到局域网的所有包，　这显示不是我们想要的，　所以我们需要里了解tcpdump的一些参数，来抓到自己想要的数据包．&lt;/p&gt;

&lt;p&gt;这篇文章里我会记录 tcpdump 的这些知识点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基本用法&lt;/li&gt;
  &lt;li&gt;ip包过滤用法&lt;/li&gt;
  &lt;li&gt;tcp包过滤用法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;基本用法&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;指定包数量&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;参数用于指定抓几个包．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1
10:04:46.371552 IP 192.168.31.137.32981 &amp;gt; ti-in-f113.1e100.net.https: Flags [S], seq 637679323, win 29200, options [mss 1460,sackOK,TS val 955896 ecr 0,nop,wscale 7], length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;指定网卡&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 参数用于指定网卡，　默认网卡不是确定的(大多数时候是eth0)，　所以一般需要手动指定．&lt;br /&gt;
如果我们确定数据包走哪个网卡的话，　直接指定对应的网卡即可，　通常是监听所有网卡&lt;code class=&quot;highlighter-rouge&quot;&gt;-i any&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1 -vv
22:37:11.793327 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.31.242 tell XiaoQiang, length 28
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ip&quot;&gt;显示ip和端口&lt;/h3&gt;

&lt;p&gt;上面的例子是一个ip给另一个ip发送数据，　但是我们只看到一个ip, 原因是tcpdump默认显示名字了．&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 参数可以把能显示为数字的地方都显示为数字形式．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1 -vv -n

22:38:39.989938 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.31.242 tell 192.168.31.1, length 28
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ip-1&quot;&gt;过滤ip&lt;/h3&gt;

&lt;p&gt;如果我告诉大家我的ip是&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.31.137&lt;/code&gt;时，　大家就会有一个问题：怎么抓到与本机无关的数据包了呢．&lt;br /&gt;
是的，tcpdump默认抓的是整个局域网路过当前主机网卡的包．&lt;/p&gt;

&lt;p&gt;那紧接着我们的问题是怎么根据ip来过滤自己感兴趣的数据包．&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;参数用于指定包的ip.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1 -n host 192.168.31.137
23:43:01.238368 IP 192.168.31.137.53189 &amp;gt; 52.175.36.207.22: Flags [P.], seq 2371045085:2371045189, ack 3267945999, win 2643, options [nop,nop,TS val 5682688 ecr 346768222], length 104
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有时候我们希望只显示来源ip或者回包ip是指定的值．&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;src host&lt;/code&gt;用于指定来源ip, &lt;code class=&quot;highlighter-rouge&quot;&gt;dst host&lt;/code&gt;用于指定回包ip.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1 -n src host 192.168.31.137
23:41:58.518326 IP 192.168.31.137.57938 &amp;gt; 64.233.188.188.5228: Flags [.], ack 3691415719, win 341, options [nop,nop,TS val 5667008 ecr 4279437604], length 0

tiankonguse:~ $ sudo tcpdump -iany  -c 1 -n dst host 192.168.31.137
23:42:23.005982 IP 203.208.50.127.443 &amp;gt; 192.168.31.137.43815: Flags [.], ack 698499583, win 235, options [nop,nop,TS val 1794601452 ecr 5661867], length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;过滤端口&lt;/h3&gt;

&lt;p&gt;过滤端口和过滤ip类似．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump port 80  
tcpdump src port 80  
tcpdump dst port 80  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;过滤协议&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump arp  
sudo tcpdump ip  
sudo tcpdump tcp  
sudo tcpdump udp  
sudo tcpdump icmp  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;过滤网络&lt;/h3&gt;

&lt;p&gt;上面提到tcpdump抓的是局域网的包，　那怎么过滤多个ip的包呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump net 192.168  
tcpdump src net 192.168  
tcpdump dst net 192.168  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;其他常用参数&lt;/h3&gt;

&lt;p&gt;有时候对于文本协议，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt;参数来直接显示出来，　这样方便我们直接查看或者使用命令进一步处理．&lt;/p&gt;

&lt;p&gt;有时候我们的文本包很大，　我们会发现输出的包只有65535字节，此时可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;参数来指定buf大小．&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-s0&lt;/code&gt;代表不限制buf, 这时常用的参数．&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;参数是使输出使用行buf, 这样遇到行结束符就马上输出内容．对于http包很有用．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany -Anlps0 host 192.168.31.137 and  dst port 80

23:37:43.947078 IP 192.168.31.137.54331 &amp;gt; 14.17.32.223.80: Flags [P.], seq 0:1094, ack 1, win 229, length 1094
E..n..@.@.l....... ..;.P+.:...I.P.......GET /fcgi-bin/dlib/dataout_ex?auto_id=1518&amp;amp;otype=json HTTP/1.1
Host: sns.video.qq.com
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.6
Cookie: ．．．
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-9&quot;&gt;输出到文件&lt;/h3&gt;

&lt;p&gt;如果仅仅希望抓到的文本内容输出到文件，　直接使用重定向参数&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;来写到文件即可．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 5 -Anlps0 host 192.168.31.137 and  dst port 80 &amp;gt; test.txt
5 packets captured

tiankonguse:~ $ head -n20 test.txt
23:38:36.663699 IP 192.168.31.137.54334 &amp;gt; 14.17.32.223.80: Flags [P.], seq 0:1094, ack 1, win 229, length 1094
E..n..@.@......... ..&amp;gt;.P..=H_JE.P...3I..GET /fcgi-bin/dlib/dataout_ex?auto_id=1518&amp;amp;otype=json HTTP/1.1
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果希望包的所有信息都保存起来，　可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt;参数重定向到文件中,这样可以使用对于的包解析软件查看或者后续使用tcpdump静态分析包内容．&lt;br /&gt;
使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt;写到文件的内容可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;重新读入．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 5 -Anlps0 host 192.168.31.137 and  dst port 80 -w test.pac
tiankonguse:~ $ sudo tcpdump -iany  -c 5 -Anlps0 host 192.168.31.137 and  dst port 80 -r test.pac
23:40:33.106822 IP 192.168.31.137.54343 &amp;gt; 14.17.32.223.80: Flags [P.], seq 0:1094, ack 1, win 229, length 1094
E..n..@.@.I....... ..G.P.....%..P.......GET /fcgi-bin/dlib/dataout_ex?auto_id=1518&amp;amp;otype=json HTTP/1.1
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;条件运算&lt;/h3&gt;

&lt;p&gt;有时候我们希望使用多个条件组合，　我们可以使用条件表达式来筛选自己想要的包．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非: &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;且: &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;或: &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如希望抓来源ip是&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.31.137&lt;/code&gt;的回包ip不是&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.31.136&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;包．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 5 -Anlps0 &quot;tcp and (src host 192.168.31.137) and (not dst host 192.168.31.136)&quot;
23:59:17.712051 IP 192.168.31.137.38330 &amp;gt; 203.208.50.183.443: Flags [F.], seq 1523331540, ack 2978034757, win 245, options [nop,nop,TS val 5926806 ecr 1374226439], length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-11&quot;&gt;高级过滤&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;过滤理论&lt;/h3&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;得到包中任何位置的值，　从而进行计算筛选．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;含义为从第&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;字节起数&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;个字节．&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y] &amp;amp; z = 0&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 的与操作为0&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y] &amp;amp; z !=0&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 的与操作不为0&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y] &amp;amp; z = z&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 的与操作为&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y] = z&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;proto[x:y]&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持的操作符有下面几个:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;  大于&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;  小于&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt; 大于或者等于&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt; 小于或等于&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;  等于&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt; 不等于&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-2&quot;&gt;IP包头&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 0               1               2               3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    | &amp;lt;-- optional
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            DATA ...                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通常第一个字节的二进制为&lt;code class=&quot;highlighter-rouge&quot;&gt;01000101&lt;/code&gt;.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;0100&lt;/code&gt;代表IP的版本4, &lt;code class=&quot;highlighter-rouge&quot;&gt;0101&lt;/code&gt;代表包头大小为`5 x 32｀比特，也就是20字节．&lt;/p&gt;

&lt;p&gt;当是&lt;code class=&quot;highlighter-rouge&quot;&gt;IPV6&lt;/code&gt;的情况时，版本信息肯定是超过&lt;code class=&quot;highlighter-rouge&quot;&gt;01000101&lt;/code&gt;,如果是带有&lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt;选项设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;IPV4&lt;/code&gt;也有可能在版本信息中超过&lt;code class=&quot;highlighter-rouge&quot;&gt;01000101&lt;/code&gt;.&lt;br /&gt;
所以如果我们想检查包是否为&lt;code class=&quot;highlighter-rouge&quot;&gt;IPV4&lt;/code&gt;且不带选项的话，　可以判断&lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt;包的第一字节是否等于&lt;code class=&quot;highlighter-rouge&quot;&gt;01000101 = 69&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 2 -Anlps0 &quot;ip[0] = 69&quot;

00:20:20.907118 IP 192.168.31.214.17500 &amp;gt; 255.255.255.255.17500: UDP, length 132
E.......@...........D\D\....{&quot;host_int&quot;: 270851488261285451571361433399569786517, &quot;version&quot;: [2, 0], &quot;displayname&quot;: &quot;&quot;, &quot;port&quot;: 17500, &quot;namespaces&quot;: [28932611]}

00:20:38.624365 IP 192.168.31.1.43285 &amp;gt; 239.255.255.250.1900: UDP, length 374
E.....@................l.~..NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=60
LOCATION: http://192.168.31.1:5351/rootDesc.xml
SERVER: MiWiFi/x UPnP/1.1 MiniUPnPd/1.9
NT: upnp:rootdevice
USN: uuid:3f705d5b-6c54-4b73-94bf-be06dced73d4::upnp:rootdevice
NTS: ssdp:alive
OPT: &quot;http://schemas.upnp.org/upnp/1/0/&quot;; ns=01
01-NLS: 1
BOOTID.UPNP.ORG: 1
CONFIGID.UPNP.ORG: 1337
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，数字也可以使用十六进制的形式．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 5 -Anlps0 &quot;ip[0] = 0x45&quot;
00:52:03.311907 IP 192.168.31.214.60108 &amp;gt; 239.255.255.250.1900: UDP, length 175
E.........2............l.._.M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
MAN: &quot;ssdp:discover&quot;
MX: 1
ST: urn:dial-multiscreen-org:service:dial:1
USER-AGENT: Google Chrome/52.0.2743.116 Mac OS X
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;DF:Don’t Fragment&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IP协议的首部“标志”中标志(flag) 占 3 位，目前只有前两位有意义。&lt;br /&gt;
标志字段的最低位是 MF (More Fragment)。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;MF =1&lt;/code&gt; 表示后面“还有分片”。&lt;code class=&quot;highlighter-rouge&quot;&gt;MF = 0&lt;/code&gt; 表示最后一个分片。&lt;br /&gt;
标志字段中间的一位是 DF (Don’t Fragment) 只有当 DF =0 时才允许分片。&lt;/p&gt;

&lt;p&gt;现在看下如何让我们知道是否有分片发生，当发送设备的MTU大于沿途设备的MTU时，就要分片&lt;br /&gt;
分片标志可以在IP头的第七和第八字节找到&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Bit 0:     reserved, must be zero
Bit 1:     (DF) 0 = May Fragment, 1 = Don't Fragment.
Bit 2:     (MF) 0 = Last Fragment, 1 = More Fragments.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tcp-header&quot;&gt;TCP header&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 0               1               2               3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |       |C|E|U|A|P|R|S|F|                               |
| Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |
|       |       |R|E|G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;过滤来源ip端口是80的数据包．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump -iany  -c 5 -Anlps0 &quot;tcp[0:2] = 80&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;过滤区间端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump -iany  -c 5 -Anlps0 &quot;portrange 80-8080&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP协议是有状态的，这些状态在TCP包的第１４字节．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 7 6 5 4 3 2 1 0 
+-+-+-+-+-+-+-+-+
|C|E|U|A|P|R|S|F|
|W|C|R|C|S|S|Y|I|
|R|E|G|K|H|T|N|N|
+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP的三次握手过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Source sends SYN 发起方发SYN&lt;/li&gt;
  &lt;li&gt;Destination answers with SYN, ACK  目的方回答SYN+ACK&lt;/li&gt;
  &lt;li&gt;Source sends ACK 发起方发ACK&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如想筛选传输数据的包，可以这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump -iany  -c 1 -n 'port 80 and tcp[13] &amp;amp; 8 = 8'

01:07:21.003121 IP 192.168.31.137.54649 &amp;gt; 14.17.32.223.80: Flags [P.], seq 3921785767:3921786861, ack 3457503231, win 229, length 1094
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，对于这些flag可以直接使用名字的．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FIN: tcp-fin&lt;/li&gt;
  &lt;li&gt;SYN: tcp-syn&lt;/li&gt;
  &lt;li&gt;PSH: tcp-push&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tiankonguse:~ $ sudo tcpdump -iany  -c 1 -n 'port 80 and tcp[tcpflags] &amp;amp; tcp-push == tcp-push'

01:14:09.648088 IP 192.168.31.137.54691 &amp;gt; 14.17.32.223.80: Flags [P.], seq 2379636258:2379637352, ack 4207633297, win 229, length 1094
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;tcpdump文档中给的抓有数据的http的实例是这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;amp;0xf)&amp;lt;&amp;lt;2)) - ((tcp[12]&amp;amp;0xf0)&amp;gt;&amp;gt;2)) != 0)'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ip[2:2]&lt;/code&gt;代表整个包大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ip[0]&amp;amp;0xf)&amp;lt;&amp;lt;2&lt;/code&gt; 代表ip包头大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(ip[2:2] - ((ip[0]&amp;amp;0xf)&amp;lt;&amp;lt;2))&lt;/code&gt; 就代表ip包的数据部分大小，既tcp整个包大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;((tcp[12]&amp;amp;0xf0)&amp;gt;&amp;gt;2)&lt;/code&gt; 代表tcp数据偏移量，　当偏移量和包大小不等时，说明带的有附加数据．&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;udp-header&quot;&gt;UDP header&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  0      7 8     15 16    23 24    31  
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |                 |                 |
 |     Length      |    Checksum     |
 +--------+--------+--------+--------+
 |                                   |
 |              DATA ...             |
 +-----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个比较简单，没什么讲的，　直接使用tcp的基本过滤规则过滤即可．&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>删除文件未释放空间</title>
     <link href="http://localhost:4000/blog/2016/08/12/delete_file_no_freed_space.html"/>
     <updated>2016-08-12T21:08:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/12/delete_file_no_freed_space</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;经常遇到服务器上的日志文件太大导致磁盘满了, 如果直接删除的话, 会发现空间并没有释放.&lt;br /&gt;
有时候我们发现文件满了, 却找不到大文件.&lt;br /&gt;
这篇文章记录这么两个知识点.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;现象&lt;/h2&gt;

&lt;p&gt;问题的现象是服务器的磁盘满了.&lt;/p&gt;

&lt;p&gt;有时是我们手动删除了大文件, 发现空闲磁盘大小并没有增加.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_00@Tencent64:~&amp;gt; df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             9.2G  1.8G  7.0G  20% /
udev                  3.9G  256K  3.9G   1% /dev
/dev/sda3              19G  16G   16G  100% /usr/local
/dev/sda4             430G  6.2G  402G   2% /data
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有时是我们登陆服务器没找到大文件, 但是磁盘不足了.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_00@Tencent64:/usr/local/services&amp;gt; du -h | grep M
1.3M    ./ccagent-0.2/bin
1.4M    ./ccagent-0.2
20M     ./itil_dt_server-0.1/bin
20M     ./itil_dt_server-0.1
1.2M    ./core_check-1.0/admin/data/tmp
1.2M    ./core_check-1.0/admin/data
1.3M    ./core_check-1.0/admin
1.3M    ./core_check-1.0
4.4M    ./spp_searchpool-2.3/bin/lib
8.7M    ./spp_searchpool-2.3/bin
1.8M    ./spp_searchpool-2.3/client/spp_searchpool/lib
1.8M    ./spp_searchpool-2.3/client/spp_searchpool/module
3.9M    ./spp_searchpool-2.3/client/spp_searchpool
3.9M    ./spp_searchpool-2.3/client
1.5M    ./spp_searchpool-2.3/stat
192M    ./spp_searchpool-2.3/moni
206M    ./spp_searchpool-2.3
...
...
...
5.0M    ./uniq_client-1.0
345M    .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;

  &lt;p&gt;这里先不考虑大量小文件的情况.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;理论知识&lt;/h2&gt;

&lt;p&gt;在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).&lt;br /&gt;
然而如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt;找到被删除但是fd没释放的文件.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[user_00@V_10_242_131_86 /usr/local/services/spp_list_server_access-2.3/log]$  lsof |grep deleted
unified_c 24853 user_00    2w      REG                8,1        48      50670 /var/spool/cronx/std_logs/stderr_21981_24084_1_153625_1449980771_60 (deleted)
unified_c 24854 user_00    2w      REG                8,1        48      50670 /var/spool/cronx/std_logs/stderr_21981_24084_1_153625_1449980771_60 (deleted)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以找到占用删除文件的进程列表了, 然后杀死(&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9&lt;/code&gt;)对于的进程或者重启对于的服务即可.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;其他知识&lt;/h2&gt;

&lt;p&gt;说到这里, 可能有人要问: 当我知道一个文件很大时, 该如何清理呢?&lt;/p&gt;

&lt;p&gt;答案是使用重定向重新写该文件即可.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &amp;gt; file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>virtualbox网络的一些记录</title>
     <link href="http://localhost:4000/blog/2016/08/07/virtualhost-net.html"/>
     <updated>2016-08-07T10:52:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/08/07/virtualhost-net</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;要想登录公司的vpn, 必须在windows上安装内部软件．&lt;br /&gt;
我的电脑只安装了ubuntu, 于是只好安装一个虚拟机，然后在虚拟机里面安装windows.&lt;br /&gt;
远程开发也都是在虚拟机内完成的．&lt;/p&gt;

&lt;p&gt;但是我的电脑配置不是很高，　所以在虚拟机内操作就变得很卡，　于是想这能不能虚拟机仅用于连vpn, 开发仍在ubuntu上进行．&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;核心问题&lt;/h2&gt;

&lt;p&gt;目前虚拟机内的windows已连上vpn, 目的是让虚拟机外的系统使用虚拟机内的网络．&lt;br /&gt;
这就需要研究一下virtualbox的网络，　然后搭建一个能满足需求的网络．&lt;/p&gt;

&lt;p&gt;＞ PS: 当然，　可能有人会说直接研究如何在ununtu下直接连上公司的vpn不是更方便吗？
＞ 答: 是的，　但是现在需要优先产品需求解决问题，　至于体验优化，需要有时间再做(其实优化问题一直都排不上期的)．&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;核心技术&lt;/h2&gt;

</content>
   </entry>
   
    
   <entry>
     <title>数据一致性-分区可用性-性能</title>
     <link href="http://localhost:4000/blog/2016/07/20/data-cap.html"/>
     <updated>2016-07-20T19:30:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/07/20/data-cap</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;这篇记录接下来的部分，将跳出任何一种数据库，从原理的角度上来分析下面的几个问题：&lt;/p&gt;

&lt;p&gt;问题一：数据一致性。在不使用共享存储的情况下，传统RDBMS（例如：Oracle/MySQL/PostgreSQL等），能否做到在主库出问题时的数据零丢失。&lt;br /&gt;
问题二：分区可用性。有多个副本的数据库，怎么在出现各种问题时保证系统的持续可用？&lt;br /&gt;
问题三：性能。不使用共享存储的RDBMS，为了保证多个副本间的数据一致性，是否会损失性能？如何将性能的损失降到最低？&lt;br /&gt;
问题四：一个极端场景的分析。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;问题一：数据一致性&lt;/h2&gt;

&lt;p&gt;问：脱离了共享存储，传统关系型数据库就无法做到主备强一致吗？&lt;/p&gt;

&lt;p&gt;答：我的答案，是No。哪怕不用共享存储，任何数据库，也都可以做到主备数据的强一致。Oracle如此，MySQL如此，PostgreSQL如此，OceanBase也如此。&lt;/p&gt;

&lt;p&gt;如何实现主备强一致？大家都知道数据库中最重要的一个技术：WAL（&lt;a href=&quot;https://en.wikipedia.org/wiki/Write-ahead_logging&quot;&gt;Write-Ahead-Logging&lt;/a&gt;）。更新操作写日志（Oracle Redo Log，MySQL Binlog等），事务提交时，保证将事务产生的日志先刷到磁盘上，保证整个事务的更新操作数据不丢失。那实现数据库主备数据强一致的方法也很简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;事务提交的时候，同时发起两个写日志操作，一个是将日志写到本地磁盘的操作，另一个是将日志同步到备库并且确保落盘的操作；&lt;/li&gt;
  &lt;li&gt;主库此时等待两个操作全部成功返回之后，才返回给应用方，事务提交成功；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个事务提交操作的逻辑，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1633108300.jpg&quot; alt=&quot;img-medish&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所示，由于事务提交操作返回给应用时，事务产生的日志在主备两个数据库上都已经存在了，强同步。&lt;br /&gt;
因此，此时主库Crash的话，备库提供服务，其数据与主库是一致的，没有任何事务的数据丢失问题。主备数据强一致实现。&lt;br /&gt;
用过Oracle的朋友，应该都知道Oracle的Data Guard，可工作在 最大性能，最大可用，最大保护 三种模式下，其中第三种 最大保护 模式，采用的就是上图中的基本思路。&lt;/p&gt;

&lt;p&gt;实现数据的强同步实现之后，接下来到了考虑可用性问题。&lt;br /&gt;
现在已经有主备两个数据完全一致的数据库，备库存在的主要意义，就是在主库出故障时，能够接管应用的请求，确保整个数据库能够持续的提供服务：主库Crash，备库提升为主库，对外提供服务。&lt;br /&gt;
此时，又涉及到一个决策的问题，主备切换这个操作谁来做？人当然可以做，接收到主库崩溃的报警，手动将备库切换为主库。&lt;br /&gt;
但是，手动的效率是低下的，更别提数据库可能会随时崩溃，全部让人来处理，也不够厚道。&lt;br /&gt;
一个HA（High Availability）检测工具应运而生：HA工具一般部署在第三台服务器上，同时连接主备，当其检测到主库无法连接，就切换备库，很简单的处理逻辑&lt;br /&gt;
如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1297456834.jpg&quot; alt=&quot;img-Ex6AqotP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HA软件与主备同时连接，并且有定时的心跳检测。&lt;br /&gt;
主库Crash后，HA探测到，发起一个将备库提升为主库的操作（修改备库的VIP或者是DNS，可能还需要将备库激活等一系列操作），新的主库提供对外服务。&lt;br /&gt;
此时，由于主备的数据是通过日志强同步的，因此并没有数据丢失，数据一致性得到了保障。&lt;/p&gt;

&lt;p&gt;有了基于日志的数据强同步，有了主备自动切换的HA软件，是不是就一切万事大吉了？&lt;br /&gt;
我很想说是，确实这个架构已经能够解决90%以上的问题，但是这个架构在某些情况下，也埋下了几个比较大的问题。&lt;/p&gt;

&lt;p&gt;首先，一个一目了然的问题，主库Crash，备库提升为主库之后，此时的数据库是一个单点，原主库重启的这段时间，单点问题一直存在。&lt;br /&gt;
如果这个时候，新的存储再次Crash，整个系统就处于不可用状态。&lt;br /&gt;
此问题，可以通过增加更多副本，更多备库的方式解决，例如3副本（一主两备），此处略过不表。&lt;/p&gt;

&lt;p&gt;其次，在主备环境下，处理主库挂的问题，算是比较简单的，决策简单：主库Crash，切换备库。&lt;br /&gt;
但是，如果不是主库Crash，而是网络发生了一些问题，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2651873794.jpg&quot; alt=&quot;img-Ex6AqfEj&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若Master与Slave之间的网络出现问题，例如：断网，网络抖动等。&lt;br /&gt;
此时数据库应该怎么办？Master继续提供服务？Slave没有同步日志，会数据丢失。Master不提供服务？应用不可用。&lt;br /&gt;
在Oracle中，如果设置为 最大可用 模式，则此时仍旧提供服务，允许数据不一致；如果设置为 最大保护 模式，则Master不提供服务。&lt;br /&gt;
因此，在Oracle中，如果设置为 最大保护 模式，一般建议设置两个或以上的Slave，任何一个Slave日志同步成功，Master就继续提供服务，提供系统的可用性。&lt;/p&gt;

&lt;p&gt;网络问题不仅仅出现在Master和Slave之间，同样也可能出现在HA与Master，HA与Slave之间。&lt;br /&gt;
考虑下面的这种情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1813158624.jpg&quot; alt=&quot;img-Ex6AqzNF&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HA与Master之间的网络出现问题，此时HA面临两个抉择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HA到Master之间的连接不通，认为主库Crash。&lt;br /&gt;
选择将备库提升为主库。&lt;br /&gt;
但实际上，只是HA到Master间的网络有问题，原主库是好的（没有被降级为备库，或者是关闭），仍旧能够对外提供服务。&lt;br /&gt;
新的主库也可以对外提供服务。&lt;br /&gt;
两个主库，产生双写问题，最为严重的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HA到Master之间的连接不通，认为是网络问题，主库未Crash。&lt;br /&gt;
HA选择不做任何操作。
但是，如果这时确实是主库Crash了，HA不做操作，数据库不对外提供服务。&lt;br /&gt;
双写问题避免了，但是应用的可用性受到了影响。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，数据库会出现问题，数据库之间的网络会出现问题，那么再考虑一层，HA软件本身也有可能出现问题。&lt;br /&gt;
如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/607498740.jpg&quot; alt=&quot;img-Ex6Arh9c&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果是HA软件本身出现了问题，怎么办？&lt;br /&gt;
我们通过部署HA，来保证数据库系统在各种场景下的持续可用，但是HA本身的持续可用谁来保证？&lt;br /&gt;
难道我们需要为HA做主备，然后再HA之上再做另一层HA？一层层加上去，子子孙孙无穷尽也 … …&lt;/p&gt;

&lt;p&gt;其实，上面提到的这些问题，其实就是经典的分布式环境下的一致性问题（&lt;a href=&quot;https://en.wikipedia.org/wiki/Consensus_(computer_science)&quot;&gt;Consensus&lt;/a&gt;）&lt;br /&gt;
近几年比较火热的Lamport老爷子的&lt;a href=&quot;https://en.wikipedia.org/wiki/Paxos_(computer_science)&quot;&gt;Paxos&lt;/a&gt;协议，Stanford大学最近发表的&lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft&lt;/a&gt;协议，都是为了解决这一类问题。&lt;br /&gt;
对Raft协议感兴趣的朋友，可以再看一篇Raft的动态演示PPT：&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;Understandable Distributed Consensus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;问题二：分区可用性&lt;/h2&gt;

&lt;p&gt;前面，我们回答了第一个问题，数据库如果不使用共享存储，能否保证主备数据的强一致？答案是肯定的：可以。&lt;br /&gt;
但是，通过前面的分析，我们又引出了第二个问题：如何保证数据库在各种情况下的持续可用？至少前面提到的HA机制无法保证。&lt;br /&gt;
那么是否可以引入类似于Paxos，Raft这样的分布式一致性协议，来解决上面提到的各种问题呢？&lt;/p&gt;

&lt;p&gt;答案是可以的，我们可以通过引入类Paxos，Raft协议，来解决上面提到的各类问题，保证整个数据库系统的持续可用。&lt;br /&gt;
考虑仍旧是两个数据库组成的主备强一致系统，仍旧使用HA进行主备监控和切换，再回顾一下上一节新引入的两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HA软件自身的可用性如何保证？&lt;/li&gt;
  &lt;li&gt;如果HA软件无法访问主库，那么这时到底是主库Crash了呢？还是HA软件到主库间的网络出现问题了呢？如何确保不会同时出现两个主库，不会出现双写问题？&lt;/li&gt;
  &lt;li&gt;如何在解决上面两个问题的同时，保证数据库的持续可用？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这些问题，新的系统如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/456890387.jpg&quot; alt=&quot;img-Ex6AqQRb&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相对于之前的系统，可以看到这个系统的复杂性明显增高，而且不止一成。数据库仍旧是一主一备，数据强同步。&lt;br /&gt;
但是除此之外，多了很多变化，这些变化包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据库上面分别部署了HA Client；&lt;/li&gt;
  &lt;li&gt;原来的一台HA主机，扩展到了3台HA主机。一台是HA Master，其余的为HA Participant；&lt;/li&gt;
  &lt;li&gt;HA主机与HA Client进行双向通讯。HA主机需要探测HA Client所在的DB是否能够提供服务，这个跟原有一致。但是，新增了一条HA Client到HA主机的Master Lease通讯。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些变化，能够解决上面的两个问题吗？让我们一个一个来分析。首先是：HA软件自身的可用性如何保证？&lt;/p&gt;

&lt;p&gt;从一台HA主机，增加到3台HA主机，正是为了解决这个问题。&lt;br /&gt;
HA服务，本身是无状态的，3台HA主机，可以通过Paxos/Raft进行自动选主。&lt;br /&gt;
选主的逻辑，我这里就不做赘述，不是本文的重点，想详细了解其实现的，可以参考互联网上洋洋洒洒的关于Paxos/Raft的相关文章。&lt;br /&gt;
总之，通过部署3台HA主机，并且引入Paxos/Raft协议，HA服务的高可用可以解决。HA软件的可用性得到了保障。&lt;/p&gt;

&lt;p&gt;第一个问题解决，再来看第二个问题：如何识别出当前是网络故障，还是主库Crash？如何保证任何情况下，数据库有且只有一个主库提供对外服务？&lt;/p&gt;

&lt;p&gt;通过在数据库服务器上部署HA Client，并且引入HA Client到HA Master的租约（Lease）机制，这第二个问题同样可以得到完美的解决。&lt;br /&gt;
所谓HA Client到HA Master的租约机制，就是说图中的数据库实例，不是永远持有主库（或者是备库）的权利。&lt;br /&gt;
当前主库，处于主库状态的时间是有限制的，例如：10秒。&lt;br /&gt;
每隔10秒，HA Client必须向HA Master发起一个新的租约，续租它所在的数据库的主库状态，只要保证每10秒收到一个来自HA Master同意续租的确认，当前主库一直不会被降级为备库。&lt;/p&gt;

&lt;p&gt;第二个问题，可以细分为三个场景：&lt;/p&gt;

&lt;p&gt;场景一：主库Crash，但是主库所在的服务器正常运行，HA Client运行正常&lt;br /&gt;
主库Crash，HA Client正常运行。这种场景下，HA Client向HA Master发送一个放弃主库租约的请求，HA Master收到请求，直接将备库提升为主库即可。&lt;br /&gt;
原主库起来之后，作为备库运行。&lt;/p&gt;

&lt;p&gt;场景二：主库所在的主机Crash。（主库和HA Client同时Crash）&lt;br /&gt;
此时，由于HA Client和主库同时Crash，HA Master到HA Client间的通讯失败。&lt;br /&gt;
这个时候，HA Master还不能立即将备库提升为主库，因为区分不出场景二和接下来的场景三（网络问题）。&lt;br /&gt;
因此，HA Master会等待超过租约的时间（例如：12秒），如果租约时间之内仍旧没有续租的消息。&lt;br /&gt;
那么HA Master将备库提升为主库，对外提供服务。&lt;br /&gt;
原主库所在的主机重启之后，以备库的状态运行。&lt;/p&gt;

&lt;p&gt;场景三：主库正常，但是主库到HA Master间的网络出现问题&lt;br /&gt;
对于HA Master来说，是区分不出场景二和场景三的。&lt;br /&gt;
因此，HA Master会以处理场景二同样的逻辑处理场景三。&lt;br /&gt;
等待超过租约的时间，没有收到续租的消息，提升原备库为主库。&lt;br /&gt;
但是在提升备库之前，原主库所在的HA Client需要做额外的一点事。原主库HA Client发送给HA Master的续租请求，由于网络问题，一直没有得到响应，超过租约时间，主动将本地的主库降级为备库。&lt;br /&gt;
如此一来，待HA Master将原备库提升为主库时，原来的主库已经被HA Client降级为备库。&lt;br /&gt;
双主的情况被杜绝，应用不可能产生双写。&lt;/p&gt;

&lt;p&gt;通过以上三个场景的分析，问题二同样在这个架构下被解决了。&lt;br /&gt;
而解决问题二的过程中，系统最多需要等待租约设定的时间，如果租约设定为10秒，那么出各种问题，数据库停服的时间最多为10秒，基本上做到了持续可用。&lt;br /&gt;
这个停服的时间，完全取决于租约的时间设置。&lt;/p&gt;

&lt;p&gt;到这儿基本可以说，要实现一个持续可用（分区可用性保证），并且保证主备数据强一致的数据库系统，是完全没问题的。&lt;br /&gt;
在现有数据库系统上做改造，也是可以的。&lt;br /&gt;
但是，如果考虑到实际的实现，这个复杂度是非常高的。&lt;br /&gt;
数据库的主备切换，是数据库内部实现的，此处通过HA Master来提升主库；通过HA Client来降级备库；保证数据库崩溃恢复后，恢复为备库；通过HA Client实现主库的租约机制；实现HA主机的可用性；所有的这些，在现有数据库的基础上实现，都有着相当的难度。&lt;br /&gt;
能够看到这儿，而且有兴趣的朋友，可以针对此问题进行探讨J&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;问题三：性能&lt;/h2&gt;

&lt;p&gt;数据一致性，通过日志的强同步，可以解决。&lt;br /&gt;
分区可用性，在出现任何异常情况时仍旧保证系统的持续可用，可以在数据强同步的基础上引入Paxos/Raft等分布式一致性协议来解决，虽然这个目前没有成熟的实现。&lt;br /&gt;
接下来再让我们来看看一个很多朋友都很感兴趣的问题：如何在保证强同步的基础上，同时保证高性能？&lt;br /&gt;
回到我们本文的第一幅图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1633108300.jpg&quot; alt=&quot;img-medish&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了保证数据强同步，应用发起提交事务的请求时，必须将事务日志同步到Slave，并且落盘。&lt;br /&gt;
相对于异步写Slave，同步方式多了一次Master到Slave的网络交互，同时多了一次Slave上的磁盘sync操作。&lt;br /&gt;
反应到应用层面，一次Commit的时间一定是增加了，具体增加了多少，要看主库到备库的网络延时和备库的磁盘性能。&lt;/p&gt;

&lt;p&gt;为了提高性能，第一个很简单的想法，就是部署多个Slave，只要有一个Slave的日志同步完成返回，加上本地的Master日志也已经落盘，提交操作就可以返回了。&lt;br /&gt;
多个Slave的部署，对于消除瞬时的网络抖动，非常有效果。&lt;br /&gt;
在Oracle的官方建议中，如果使用最大保护模式，也建议部署多个Slave，来最大限度的消除网络抖动带来的影响。&lt;br /&gt;
如果部署两个Slave，新的部署架构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2757718661.jpg&quot; alt=&quot;img-Ex6AqZO7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新增一个Slave，数据三副本。&lt;br /&gt;
两个Slave，只要有一个Slave日志同步完成，事务就可以提交，极大地减少了某一个网络抖动造成的影响。&lt;br /&gt;
增加了一个副本之后，还能够解决当主库Crash之后的数据安全性问题，哪怕主库Crash，仍旧有两个副本可以提供服务，不会形成单点。&lt;/p&gt;

&lt;p&gt;但是，在引入数据三副本之后，也新引入了一个问题：主库Crash的时候，到底选择哪一个备库作为新的主库？&lt;br /&gt;
当然，选主的权利仍旧是HA Master来行使，但是HA Master该如何选择？&lt;br /&gt;
这个问题的简单解决可以使用下面的几个判断标准：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;日志优先。两个Slave，哪个Slave拥有最新的日志，则选择这个Slave作为新的主库。&lt;/li&gt;
  &lt;li&gt;主机层面排定优先级。
如果两个Slave同时拥有最新的日志，那么该如何选择？&lt;br /&gt;
此时，选择任何一个都是可以的。&lt;br /&gt;
例如：可以根据Slave主机IP的大小进行选择，选择IP小的Slave作为新的主库。同样能够解决问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新的主库选择出来之后，第一件需要做的事，就是将新的Master和剩余的一个Slave，进行日志的同步，保证二者日志达到一致状态后，对应用提供服务。&lt;br /&gt;
此时，三副本问题就退化为了两副本问题，三副本带来的防止网络抖动的红利消失，但是由于两副本强同步，数据的可靠性以及一致性仍旧能够得到保障。&lt;/p&gt;

&lt;p&gt;当然，除了这一个简单的三副本优化之外，还可以做其他更多的优化。&lt;br /&gt;
优化的思路一般就是同步转异步处理，例如事务提交写日志操作；使用更细粒度的锁；关键路径可以采用无锁编程等。&lt;/p&gt;

&lt;p&gt;多副本强同步，做到极致，并不一定会导致系统的性能损失。&lt;br /&gt;
极致应该是什么样子的？我的想法是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于单个事务来说，RT增加。其响应延时一定会增加（至少多一个网络RT，多一次磁盘Sync）；&lt;/li&gt;
  &lt;li&gt;对整个数据库系统来说，吞吐量不变。远程的网络RT和磁盘Sync并不会消耗本地的CPU资源，本地CPU的开销并未增大。&lt;br /&gt;
只要是异步化做得好，整个系统的吞吐量，并不会由于引入强同步而降低。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;各种主流关系型数据库系统是否可以实现主备的强一致，是否可以保证不依赖于存储的数据一致性？&lt;br /&gt;
可以。Oracle有，MySQL 5.7，阿里云RDS，网易RDS都有类似的功能。&lt;/li&gt;
  &lt;li&gt;目前各种关系型数据库系统，能否在保证主备数据强一致的基础上，提供系统的持续可用和高性能？&lt;br /&gt;
可以做，但是难度较大，目前主流关系型数据库缺乏这个能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Write-ahead_logging&quot;&gt;Write-ahead_logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&quot;&gt;Algorithms for Recovery and Isolation Exploiting Semantics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
    
   <entry>
     <title>年轻司机介绍关联商品系统与mysql</title>
     <link href="http://localhost:4000/blog/2016/05/05/project-02-goods-mysql.html"/>
     <updated>2016-05-05T00:23:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/05/05/project-02-goods-mysql</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;这篇文章简单的记录做的一个简单的系统, 并介绍一下mysql相关的知识点.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;项目背景&lt;/h2&gt;

&lt;p&gt;以前, 视频投广告一般有这么几种形式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面上留一个固定大小位置, 用于广告系统只能显示广告.&lt;/li&gt;
  &lt;li&gt;视频编码时嵌入广告&lt;/li&gt;
  &lt;li&gt;播放器根据配置定时向广告系统拉取并显示广告.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于像广告系统拉广告的形式, 随机性有点大, 对于视频编码嵌入有过于死板.&lt;br /&gt;
而且这几种广告都与视频内容没关系.&lt;/p&gt;

&lt;p&gt;现在希望有这么一个系统: 用户看视频时, 当用户认为视频里某件物品不错时, 又推送了对应的物品广告, 用户可以点击对应的广告.&lt;br /&gt;
项目的第一期需要编辑手动打上去的, 后续可以走商家打广告, 审核通过后放出去.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;项目介绍&lt;/h2&gt;

&lt;p&gt;需要做一个伴随性广告管理后台.&lt;br /&gt;
这个后台需要支持多种广告形式, 由于广告形式未知, 所以需要拖拽式配置化.&lt;/p&gt;

&lt;p&gt;这个项目需要具备以下几个功能.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;模板拖拽式配置化(过度设计)&lt;/li&gt;
  &lt;li&gt;选择某个模板新建广告&lt;/li&gt;
  &lt;li&gt;提供几个接口供其他系统查询(其他系统曝光这个广告)&lt;/li&gt;
  &lt;li&gt;广告写入到内存型数据库中供其他系统使用&lt;/li&gt;
  &lt;li&gt;提供一个外网cgi供外网拉数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程图如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2147261086.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;项目实现&lt;/h2&gt;

&lt;p&gt;这个系统实现分为几个模块.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模板模块&lt;/h3&gt;

&lt;p&gt;一个模板支持文本组件可图片组件.&lt;br /&gt;
其中文本需要限制长度, 图片需要限制文件大小和文件尺寸.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3081596932.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;模板信息数据库储存为两个表.  &lt;br /&gt;
一张是模板的信息, 一张是模板组件的信息.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/3226317163.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;模板的功能都是由js实现.&lt;br /&gt;
后台只需要提供增删改查四个接口即可.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;商品模块&lt;/h3&gt;

&lt;p&gt;商品就是某个模板的实例化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2444463596.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;数据库简化为一张表, 商品数据储存为json.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/1003092548.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部分是模板展现, 以及数据填充.&lt;br /&gt;
需要有拉取模板列表(轻量级接口), 拉取模板详情接口, 拉取商品详情接口, 修改商品详情接口, 上传图片接口.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;写内存数据库模块&lt;/h3&gt;

&lt;p&gt;写内存数据库就是一个定时任务脚本, 由于数据量不大, 对数据实时性要求不高, 所以定时增量写还可以接受.&lt;/p&gt;

&lt;h3 id=&quot;cgi&quot;&gt;外网CGI&lt;/h3&gt;

&lt;p&gt;外网CGI只是读内存数据库, 然后返回数据.&lt;br /&gt;
所以性能还是很高的, 没什么瓶颈.&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;项目结语&lt;/h2&gt;

&lt;p&gt;做这个项目, 其实javascript用的较多, 毕竟需要实现一套模板引擎.&lt;br /&gt;
但是这里不介绍javascript, 准备下篇文章介绍.&lt;br /&gt;
这里准备介绍一下mysql数据库.&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;mysql介绍&lt;/h2&gt;

&lt;p&gt;由于mysql是DBA管理的, 所以这里不讨论mysql的主从容灾,读写分离问题.&lt;br /&gt;
这里重点介绍mysql查询.&lt;/p&gt;

&lt;p&gt;当然, 写查询的过程中, 这里更偏向于研究其中的相关算法.&lt;/p&gt;

&lt;p&gt;mysql接收到查询sql后, 一般会做下面几件事.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析sql (词法分析, 语法分析, 语义分析)&lt;/li&gt;
  &lt;li&gt;重写sql&lt;/li&gt;
  &lt;li&gt;优化sql&lt;/li&gt;
  &lt;li&gt;编译sql&lt;/li&gt;
  &lt;li&gt;执行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sql&quot;&gt;解析sql&lt;/h3&gt;

&lt;p&gt;解析很容易理解, 就像我们的编译型语言的编译器.&lt;br /&gt;
提前检查代码合法性, 并转化为内部表示法.&lt;/p&gt;

&lt;p&gt;这里主要完成下面几件事.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;词法分析 - 分成一个一个的单词和符合. 不识别的直接报错&lt;/li&gt;
  &lt;li&gt;语法分析 - 按照指定的语法, 进行匹配解析. 比如 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/select.html&quot;&gt;select&lt;/a&gt;语法.&lt;/li&gt;
  &lt;li&gt;语义分析 - 比如mysql中有各种函数, 需要检查函数是否正确调用, 类型是否正确.&lt;/li&gt;
  &lt;li&gt;数据库, 表, 字段 合法性检查. - 需要检查是否存在&lt;/li&gt;
  &lt;li&gt;权限检查 - 这个用户是否有更改操作等.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sql-1&quot;&gt;重写sql&lt;/h3&gt;

&lt;p&gt;mysql内部有很多重写规则, 当检查到和某个规则匹配时, 会执行对应的重新规则.&lt;/p&gt;

&lt;p&gt;比如子查询转化.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 
    t_meterial_relation . *
FROM
    t_meterial_relation
where
    t_meterial_relation.c_template_id in (SELECT 
            t_meterial_template.c_template_id
        FROM
            t_meterial_template
        where
            t_meterial_template.c_title like '%商品%');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可能会被转化为下面的形式(只是可能).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;explain SELECT 
    t_meterial_relation . *
FROM
    t_meterial_template,
    t_meterial_relation
where
    t_meterial_relation.c_template_id = t_meterial_template.c_template_id
        and t_meterial_template.c_title like '%商品%';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重写的目的有下面几个:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;去除不必要的运算符&lt;/li&gt;
  &lt;li&gt;排除冗余的联接&lt;/li&gt;
  &lt;li&gt;常数计算赋值&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-2&quot;&gt;优化sql&lt;/h3&gt;

&lt;p&gt;这里的优化大多数是对联接查询的优化.&lt;br /&gt;
大概方法是对每个运算标记一个成本，通过选择成本最低的一系列运算，来找到最佳的降低查询成本的方法。&lt;br /&gt;
比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;A JOIN B&lt;/code&gt; 的成本跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;B JOIN A&lt;/code&gt;的成本是不同的, 优化器会选择适当的方法进行优化.&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;查询&lt;/h3&gt;

&lt;p&gt;假设我们需要查询&lt;code class=&quot;highlighter-rouge&quot;&gt;A JOIN B&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;结语&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>年轻司机介绍补预告片系统架构与cgi</title>
     <link href="http://localhost:4000/blog/2016/05/05/project-01-trailer-and-cgi.html"/>
     <updated>2016-05-05T00:22:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/05/05/project-01-trailer-and-cgi</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;这篇文章简单的记录做的一个简单的系统, 并介绍一下cgi相关的知识点.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;项目背景&lt;/h2&gt;

&lt;p&gt;视频是一个用户粘性很低的行业.&lt;br /&gt;
而我们部门在这个行业刚起步, 很多视频内容都不完善, 即只有一个空专辑(比如XX电影的名字).&lt;br /&gt;
我曾问上级, 为什么不买往年的热门电影. &lt;br /&gt;
回答是: 对于往年的电影 如果现在去花钱买那些版权收益也不大, 对于以后的, 都是我们的, 都会买.&lt;br /&gt;
但是一个电影的预告片往往是不需要版权的, 所以这里就希望可以对往年的电影补充预告片, 这样用户进到这个专辑, 至少可以看几分钟相关的宣传内容.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;项目介绍&lt;/h2&gt;

&lt;p&gt;这个项目的目的是给空专辑补充预告片.&lt;br /&gt;
由于是从无到有的过程, 需要快速支持, 不需要做一个完善的闭环系统.&lt;/p&gt;

&lt;p&gt;这里分两个子项目:&lt;br /&gt;
1. 已经有空专辑和预告片视频了. 我们需要通过某种方法识别他们(豆瓣ID), 然后关联起来.&lt;br /&gt;
2. 只有一个空专辑, 没有预告片. 我们需要去互联网上抓取预告片, 然后关联起来.&lt;/p&gt;

&lt;p&gt;系统的架构图大概如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/449928177.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;项目实现&lt;/h2&gt;

&lt;p&gt;项目实际上分为几个模块(实际项目中对步骤进行调整优化了).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把空专辑与单视频通过豆瓣ID关联起来.&lt;br /&gt;
大概步骤如下:&lt;br /&gt;
1). 从A表中找到符合指定条件的空专辑&lt;br /&gt;
2). 从B表中找到专辑对应的豆瓣ID, 做豆瓣ID到专辑的反向关系(存在多个时, 保留最后一个专辑) &lt;br /&gt;
3). 从C表找到符合条件的单视频&lt;br /&gt;
4). 从D表找到单视频对应的豆瓣ID, 做豆瓣ID到视频的反向关系(存在多个时, 全部保留)&lt;br /&gt;
5). 扫表专辑的豆瓣ID列表, 在视频列表中看是否存在, 存在则把关系保存起来&lt;br /&gt;
6). 把找到的专辑和视频通过接口关联起来.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于没关联的空专辑抓取视频&lt;br /&gt;
 这个步骤看上面的流程图就很清晰了.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要有个简单的系统供编辑处理&lt;br /&gt;
1). 添加任务 &lt;br /&gt;
2). 展示任务列表&lt;br /&gt;
3). 编辑处理任务(编辑是否补上预告片)&lt;br /&gt;
4). 每日邮件发送统计情况&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;做这个项目的时候, 第一步和第三步是一期做的.这样可以快速的补充大量的预告片, 且准确度很高.&lt;br /&gt;
第二部分是二期做的, 需要抓取团队开发对应的功能, 而且由于是使用标题等资料搜索抓取的, 准确度很低很低.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;优化&lt;/h3&gt;

&lt;p&gt;这个项目有个特点: 快速实现.&lt;br /&gt;
对于内部空专辑和单视频关联逻辑, 没什么优化的, 历史数据跑完了, 关联的数据就几乎为0了.&lt;br /&gt;
抓取视频的准确度较低, 倒是可以优化, 但是我们是以产品驱动的, 这个项目还没上线时就已经投入其他项目了(还好上线后编辑使用没出任何问题).&lt;br /&gt;
所以这个项目的总体架构就是上图介绍的.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;项目结语&lt;/h2&gt;

&lt;p&gt;做上面项目第一期的时候, 实际上工作分为两部分:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个简单的系统&lt;/li&gt;
  &lt;li&gt;编写关联程序, 调用系统接口添加任务.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;做系统的时候, 发现周围的人都使用C++当做WEB服务器的后台开发语言, 他们还称此为cgi.&lt;br /&gt;
于是有必要了解一下cgi.&lt;/p&gt;

&lt;h2 id=&quot;cgi&quot;&gt;cgi介绍&lt;/h2&gt;

&lt;p&gt;CGI 的中文是&lt;a href=&quot;https://en.wikipedia.org/wiki/Common_Gateway_Interface&quot;&gt;通用网关接口&lt;/a&gt;.&lt;br /&gt;
阅读了WIKI, 发现把我们写的c++程序称为CGI是不恰当的.&lt;br /&gt;
因为CGI只是WEB服务器与动态处理程序之间的一个标准或协议, 我们平时写的php, python, perl和c++的二进制没有太大的区别, 都是接收请求, 处理, 返回结果.&lt;/p&gt;

&lt;p&gt;当认识到CGI只是一个协议时, 我们心里自然就会想问另一个问题: WEB服务器与动态处理程序之间是什么关系?&lt;/p&gt;

&lt;p&gt;答案也很快得到验证.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/2724143093.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着想到的第二个问题是: WEB服务器怎么识别我们的动态处理程序的.&lt;/p&gt;

&lt;p&gt;这个问题其实是两个问题.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;WEB服务器怎么知道这个请求需要动态处理程序处理.&lt;/li&gt;
  &lt;li&gt;WEB服务器怎么知道怎么执行这个动态处理程序.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于第一个问题, WEB服务器往往是通过请求URL匹配的方式识别的.&lt;br /&gt;
对于第二个问题, 其实在linux上很容易回答: linux是怎么识别我们的脚本的?&lt;/p&gt;

&lt;p&gt;在apache上, 我们通常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ScriptAlias&lt;/code&gt;来指定程序的位置.&lt;br /&gt;
而在nginx上, 我们则需要一个额外的调度器来调用对应的程序.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/173826083.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看看下面的测试程序, 我们用bash脚本也可以做网站了.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[user_00@V_10_157_52_39 /data/release/vunion.oa.com/cgi-bin]$ cat ./test.sh
#!/bin/sh
echo -e &quot;Content-type:text/html\n\n&quot;
echo -e &quot;hello&amp;lt;br&amp;gt;&quot;
echo -e &quot;$0  $*&amp;lt;br&amp;gt;&quot;
echo -e &quot;${SCRIPT_NAME}&amp;lt;br&amp;gt;&quot;
echo -e &quot;${QUERY_STRING}&amp;lt;br&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/757572620.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后, 我们的问题是: 怎么传输数据的?&lt;/p&gt;

&lt;p&gt;这个问题其实反而好回答了.&lt;br /&gt;
我们看看上面的bash脚本, 输入数据并没有使用参数传输.&lt;br /&gt;
对于bash, 传参有两种: 参数和环境变量.&lt;br /&gt;
CGI标准使用的是环境变量来传参的.&lt;/p&gt;

&lt;p&gt;而对于输出数据, 直接使用标准输出来传送数据了(不考虑 std_err).&lt;/p&gt;

&lt;p&gt;扩展问题: 我们使用什么框架来编写cgi&lt;/p&gt;

&lt;p&gt;开源, 开源, 开源!!!&lt;br /&gt;
我们cgi基础框架是开源软件: &lt;a href=&quot;http://www.clearsilver.net/&quot;&gt;clearsilver&lt;/a&gt;, 它封装了&lt;a href=&quot;http://www.clearsilver.net/docs/man_cgi.hdf&quot;&gt;cgi&lt;/a&gt;相关操作. &lt;br /&gt;
然后前辈在clearsilver的基础上, 封装了一个cgiframe框架. 开发只需要实现两个函数即可: init初始化函数, process 逻辑处理函数.&lt;br /&gt;
这里就不多说了, 封装的好处是大家开发快, 缺点是很多人都不知道底层的原理了.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;问题定位&lt;/h2&gt;

&lt;p&gt;这里把c++编写的程序称为WEB程序更合适点.&lt;br /&gt;
对于C++ 编译型WEB程序, 定位问题一般是固定的.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;万能定位法: 打日志&lt;/li&gt;
  &lt;li&gt;常驻进程定位法: gdb + strace.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有人可能会说, cgi一般会先 fork 一个进程出来, 这个怎么定位呢?&lt;/p&gt;

&lt;p&gt;其实答案很简单, gdb进入fork对应的进程即可, strace 进入fork对应的进程即可.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gdb: set follow-fork-mode child
strace: man strace  # 我不会告诉你是-f参数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;年轻的司机语言表达能力不好, 结构的组织能力也不好.&lt;/p&gt;

&lt;p&gt;其实要表达的有两点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们所在的部门起步较晚, 很多基础功能都没有, 但这不是理由, 我们会努力去做好一切的, 有问题可以随时反馈.&lt;/li&gt;
  &lt;li&gt;cgi是进来接触的第一个知识点, 了解了原理后, 会发现什么语言编写的其实都一样的.&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
    
   <entry>
     <title>从服务端反向查找客户端信息</title>
     <link href="http://localhost:4000/blog/2016/04/27/server-find-client.html"/>
     <updated>2016-04-27T22:02:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/04/27/server-find-client</id>
     <content type="html">&lt;h2 id=&quot;ip&quot;&gt;抓到客户端ip&lt;/h2&gt;

&lt;p&gt;直接&lt;code class=&quot;highlighter-rouge&quot;&gt;tcpdump&lt;/code&gt;监听服务的端口号, 找到客户端的ip.&lt;br /&gt;
比如这里服务的ip是&lt;code class=&quot;highlighter-rouge&quot;&gt;10.185.16.50&lt;/code&gt;, 端口是&lt;code class=&quot;highlighter-rouge&quot;&gt;8560&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;8563&lt;/code&gt;, 找到客户端ip是&lt;code class=&quot;highlighter-rouge&quot;&gt;10.134.131.36&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump  -iany -nlp  &quot;port 8560 or 8563&quot; -c 1         

22:17:19.955583 IP 10.130.25.95.46622 &amp;gt; 10.185.16.50.8563: P 37:74(37) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ip-1&quot;&gt;确认客户端ip&lt;/h2&gt;

&lt;p&gt;这一步实际上可以忽略, 但是如果在服务器上抓包时间和第二步的时间相差比较久, 还是确认一下比较好.&lt;br /&gt;
不然双方不好对账, 服务方说有请求, 客户端说没请求.&lt;br /&gt;
另一方面, 我们也可以看看通信频率.&lt;br /&gt;
下面抓到客户端和服务器通信, 客户端使用的端口是&lt;code class=&quot;highlighter-rouge&quot;&gt;23717&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然, 实际项目中, 请多抓包一会, 可能有多个不同的程序存在.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo tcpdump  -iany -nlp  &quot;src 10.185.16.50 and (port 8560 or 8563)&quot; -c 1

22:23:21.410760 IP 10.185.16.50.8563 &amp;gt; 10.130.25.95.23717: ....
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;找到进程名&lt;/h2&gt;

&lt;p&gt;使用客户端端口, 服务端端口或者服务端ip都可以定位到具体的进程名和进程号.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然, 实际项目中, 请不要使用 more, 而应该多监听一会, 可能有多个程序存在.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#通过客户端端口号
lsof -nP | grep 38972 | more -1

modulefra 28114 user_00 28u IPv4 1117707040 TCP 10.130.25.95:38972-&amp;gt;v.cm.com:8563 (ESTABLISHED)

#通过服务端端口号
lsof -nP | grep 8563 | more -1
sync_cove 2439 user_00 53u IPv4 1128559523 TCP 10.130.25.95:40816-&amp;gt;10.185.16.50:8563 (ESTABLISHED)

#通过服务端ip
lsof -nP | grep 10.185.16.50 | more -1
sync_cove 2439 user_00 30u IPv4 1128559486 TCP 10.130.25.95:58377-&amp;gt;10.185.16.50:8561 (ESTABLISHED)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;初级定位进程位置&lt;/h2&gt;

&lt;p&gt;如果幸运, 后面会直接显示程序的绝对路径, 但是这里很不幸, 显示的是相对路径.&lt;br /&gt;
这个时候我们就需要找到进程的&lt;code class=&quot;highlighter-rouge&quot;&gt;cwd&lt;/code&gt;所在的位置了.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps -aef |  grep sync_cove
user_00   2439     1  1 14:48 ?        00:07:26 ./sync_cover_redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;高级定位进程位置&lt;/h2&gt;

&lt;p&gt;进程运行时, 会把当前目录保存起来, 我们可以查看这个信息.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user_00@V_10_130_25_95:/proc/2439&amp;gt; ll /proc/2439
total 0
-r--------  1 user_00 users 0 Apr 27 22:34 auxv
-r--r--r--  1 user_00 users 0 Apr 27 14:48 cmdline
-r--r--r--  1 user_00 users 0 Apr 27 22:34 cpuset
lrwxrwxrwx  1 user_00 users 0 Apr 27 14:50 cwd -&amp;gt; /usr/local/services/video_write_redis-1.0/bin
-r--------  1 user_00 users 0 Apr 27 14:48 environ
lrwxrwxrwx  1 user_00 users 0 Apr 27 14:48 exe -&amp;gt; /usr/local/services/video_write_redis-1.0/bin/sync_cover_redis
dr-x------  2 user_00 users 0 Apr 27 14:48 fd
-rw-------  1 user_00 users 0 Apr 27 22:34 mapped_base
-r--r--r--  1 user_00 users 0 Apr 27 22:24 maps
-rw-------  1 user_00 users 0 Apr 27 22:34 mem
-r--r--r--  1 user_00 users 0 Apr 27 22:34 mounts
-rw-r--r--  1 user_00 users 0 Apr 27 22:34 oom_adj
-r--r--r--  1 user_00 users 0 Apr 27 22:34 oom_score
lrwxrwxrwx  1 user_00 users 0 Apr 27 14:48 root -&amp;gt; /
-rw-------  1 user_00 users 0 Apr 27 22:34 seccomp
-r--r--r--  1 user_00 users 0 Apr 27 14:49 smaps
-r--r--r--  1 user_00 users 0 Apr 27 14:48 stat
-r--r--r--  1 user_00 users 0 Apr 27 14:53 statm
-r--r--r--  1 user_00 users 0 Apr 27 14:48 status
dr-xr-xr-x 16 user_00 users 0 Apr 27 14:49 task
-r--r--r--  1 user_00 users 0 Apr 27 22:34 wchan
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;好了, 到目前我们就快乐的找到自己想要的进程以及路径了.&lt;/p&gt;

</content>
   </entry>
   
    
   <entry>
     <title>redis源码阅读之map</title>
     <link href="http://localhost:4000/blog/2016/04/18/redis-dict.html"/>
     <updated>2016-04-18T22:57:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/04/18/redis-dict</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;redis是一个很不错的NOSQL数据库。&lt;br /&gt;
关于redis的使用文档， 可以参考&lt;a href=&quot;/doc/redis/&quot;&gt;这里&lt;/a&gt;.&lt;br /&gt;
关于redis字典表的源码可以参考&lt;a href=&quot;https://github.com/tiankonguse/redis/tree/unstable/src/comlib/dict&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;功能&lt;/h2&gt;

&lt;p&gt;字典表是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value&lt;/code&gt;型的数据结构。&lt;br /&gt;
在解释型语言中，　就是对象了。比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript&lt;/code&gt;中是&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;, 在php中是关联数组。&lt;br /&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;c++&lt;/code&gt;中是map类型, 在c语言中没有内置&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value&lt;/code&gt;类型，　所以只好自己实现一个了。&lt;/p&gt;

&lt;p&gt;结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;


/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int iterators; /* number of iterators currently running */
} dict;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;字典表一般需要有下面几个基本功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建字典表(create)&lt;/li&gt;
  &lt;li&gt;添加元素(set)&lt;/li&gt;
  &lt;li&gt;得到元素(get)&lt;/li&gt;
  &lt;li&gt;查询元素(find)&lt;/li&gt;
  &lt;li&gt;删除元素(delete)&lt;/li&gt;
  &lt;li&gt;释放字典表(release)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，　也需要一些通用的操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;清空字典表(clear)&lt;/li&gt;
  &lt;li&gt;判断是否为空(empty)&lt;/li&gt;
  &lt;li&gt;当前元素个数(size)&lt;/li&gt;
  &lt;li&gt;迭代器(iterator)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实现&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;创建字典表&lt;/h3&gt;

&lt;p&gt;创建字典表就是申请内存 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;，　然后初始化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Create a new hash table */
dict *dictCreate(dictType *type, void *privDataPtr) {
    dict *d = zmalloc(sizeof(*d));
    
    _dictInit(d, type, privDataPtr);
    return d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;添加元素&lt;/h3&gt;

&lt;p&gt;创建字典表后，　就到了关键的&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作了。&lt;br /&gt;
一般对于数据结构，　&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作的实现决定了整个数据结构的实现。&lt;/p&gt;

&lt;p&gt;redis的&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作主要由下面几个步实现。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查是否需要重建hash表，需要则重建(dictIsRehashing)&lt;/li&gt;
  &lt;li&gt;得到key的hash值,当key存在时直接返回&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;(dictKeyIndex)&lt;/li&gt;
  &lt;li&gt;生成节点内存，以链表的形式插入到hash值对应的节点.&lt;/li&gt;
  &lt;li&gt;设置key的值&lt;/li&gt;
  &lt;li&gt;设置value的值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;核心代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Add an element to the target hash table */
int dictAdd(dict *d, void *key, void *val) {
    dictEntry *entry = dictAddRaw(d, key);
    
    if (!entry)
        return DICT_ERR;
    dictSetVal(d, entry, val);
    return DICT_OK;
}

dictEntry *dictAddRaw(dict *d, void *key) {
    int index;
    dictEntry *entry;
    dictht *ht;
    
    if (dictIsRehashing(d))
        _dictRehashStep(d);
    
    /* Get the index of the new element, or -1 if
     * the element already exists. */
    if ((index = _dictKeyIndex(d, key)) == -1)
        return NULL;
    
    /* Allocate the memory and store the new entry.
     * Insert the element in top, with the assumption that in a database
     * system it is more likely that recently added entries are accessed
     * more frequently. */
    ht = dictIsRehashing(d) ? &amp;amp;d-&amp;gt;ht[1] : &amp;amp;d-&amp;gt;ht[0];
    entry = zmalloc(sizeof(*entry));
    entry-&amp;gt;next = ht-&amp;gt;table[index];
    ht-&amp;gt;table[index] = entry;
    ht-&amp;gt;used++;
    
    /* Set the hash entry fields. */
    dictSetKey(d, entry, key);
    return entry;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;得到元素/查询元素&lt;/h2&gt;

&lt;p&gt;得到元素和查找元素是&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作的一个判断逻辑, 既对应上面的第二步。&lt;br /&gt;
循环里面先循环第一个hash，　再循环第二个hash这个看起来很奇怪，　后面在&lt;strong&gt;调整hash&lt;/strong&gt;小节会解释为什么会这样。&lt;/p&gt;

&lt;p&gt;核心代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dictEntry *dictFind(dict *d, const void *key) {
    dictEntry *he;
    unsigned int h, idx, table;
    
    if (d-&amp;gt;ht[0].size == 0)
        return NULL; /* We don't have a table at all */
    if (dictIsRehashing(d))
        _dictRehashStep(d);
    h = dictHashKey(d, key);
    for (table = 0; table &amp;lt;= 1; table++) {
        idx = h &amp;amp; d-&amp;gt;ht[table].sizemask;
        he = d-&amp;gt;ht[table].table[idx];
        while (he) {
            if (dictCompareKeys(d, key, he-&amp;gt;key))
                return he;
            he = he-&amp;gt;next;
        }
        if (!dictIsRehashing(d))
            return NULL;
    }
    return NULL;
}
void *dictFetchValue(dict *d, const void *key) {
    dictEntry *he;
    
    he = dictFind(d, key);
    return he ? dictGetVal(he) : NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-6&quot;&gt;删除元素&lt;/h2&gt;

&lt;p&gt;删除元素和查找元素的代码类似，　不过这里找到元素后，　需要把元素从链表中删除。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Search and remove an element */
static int dictGenericDelete(dict *d, const void *key, int nofree) {
    unsigned int h, idx;
    dictEntry *he, *prevHe;
    int table;
    
    if (d-&amp;gt;ht[0].size == 0)
        return DICT_ERR; /* d-&amp;gt;ht[0].table is NULL */
    if (dictIsRehashing(d))
        _dictRehashStep(d);
    h = dictHashKey(d, key);
    
    for (table = 0; table &amp;lt;= 1; table++) {
        idx = h &amp;amp; d-&amp;gt;ht[table].sizemask;
        he = d-&amp;gt;ht[table].table[idx];
        prevHe = NULL;
        while (he) {
            if (dictCompareKeys(d, key, he-&amp;gt;key)) {
                /* Unlink the element from the list */
                if (prevHe)
                    prevHe-&amp;gt;next = he-&amp;gt;next;
                else
                    d-&amp;gt;ht[table].table[idx] = he-&amp;gt;next;
                if (!nofree) {
                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                }
                zfree(he);
                d-&amp;gt;ht[table].used--;
                return DICT_OK;
            }
            prevHe = he;
            he = he-&amp;gt;next;
        }
        if (!dictIsRehashing(d))
            break;
    }
    return DICT_ERR; /* not found */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;释放字典表/清空字典表&lt;/h3&gt;

&lt;p&gt;释放字典表就是先情况两个字典表，然后回收内存。&lt;br /&gt;
而情况字典表则需要遍历hash数组，　删除所有链表的节点。&lt;/p&gt;

&lt;p&gt;下面唯一不明确的代码就是那个&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;, 这个需要后面再解释吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Destroy an entire dictionary */
int _dictClear(dict *d, dictht *ht, void (callback)(void *)) {
    unsigned long i;
    
    /* Free all the elements */
    for (i = 0; i &amp;lt; ht-&amp;gt;size &amp;amp;&amp;amp; ht-&amp;gt;used &amp;gt; 0; i++) {
        dictEntry *he, *nextHe;
        
        if (callback &amp;amp;&amp;amp; (i &amp;amp; 65535) == 0)
            callback(d-&amp;gt;privdata);
        
        if ((he = ht-&amp;gt;table[i]) == NULL)
            continue;
        while (he) {
            nextHe = he-&amp;gt;next;
            dictFreeKey(d, he);
            dictFreeVal(d, he);
            zfree(he);
            ht-&amp;gt;used--;
            he = nextHe;
        }
    }
    /* Free the table and the allocated cache structure */
    zfree(ht-&amp;gt;table);
    /* Re-initialize the table */
    _dictReset(ht);
    return DICT_OK; /* never fails */
}

/* Clear &amp;amp; Release the hash table */
void dictRelease(dict *d) {
    _dictClear(d, &amp;amp;d-&amp;gt;ht[0], NULL);
    _dictClear(d, &amp;amp;d-&amp;gt;ht[1], NULL);
    zfree(d);
}
void dictEmpty(dict *d, void (callback)(void*)) {
    _dictClear(d, &amp;amp;d-&amp;gt;ht[0], callback);
    _dictClear(d, &amp;amp;d-&amp;gt;ht[1], callback);
    d-&amp;gt;rehashidx = -1;
    d-&amp;gt;iterators = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hash&quot;&gt;调整hash&lt;/h3&gt;

&lt;p&gt;上面增删改成的实现都有了，　但是漏了一个重要的逻辑：调整hash.&lt;/p&gt;

&lt;p&gt;在调整hash时，　会先增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;hash[1]&lt;/code&gt;, 这时增加的时候插入到新&lt;code class=&quot;highlighter-rouge&quot;&gt;hash[1]&lt;/code&gt;中, 查询时扫描两个hash.&lt;br /&gt;
这也是上面为什么要循环两个hash的原因。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;hash[0]&lt;/code&gt;中元素太多的话，全部调整会话费很多时间。&lt;br /&gt;
所以这里选择遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;empty_visits&lt;/code&gt;次&lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;个节点就直接返回(默认n等于１)，　下次调整时继续。&lt;br /&gt;
看到这里，　也就明白了&lt;code class=&quot;highlighter-rouge&quot;&gt;d-&amp;gt;rehashidx&lt;/code&gt;的含义：记录上次调整的位置。&lt;/p&gt;

&lt;p&gt;不过我们知道redis的hash有个迭代器，　所以当有迭代器在使用hash的时候，　还是不能进行调整的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d))
        return 0;
    
    while (n-- &amp;amp;&amp;amp; d-&amp;gt;ht[0].used != 0) {
        dictEntry *de, *nextde;
        
        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d-&amp;gt;ht[0].size &amp;gt; (unsigned long )d-&amp;gt;rehashidx);
        while (d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] == NULL) {
            d-&amp;gt;rehashidx++;
            if (--empty_visits == 0)
                return 1;
        }
        de = d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            unsigned int h;
            
            nextde = de-&amp;gt;next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de-&amp;gt;key) &amp;amp; d-&amp;gt;ht[1].sizemask;
            de-&amp;gt;next = d-&amp;gt;ht[1].table[h];
            d-&amp;gt;ht[1].table[h] = de;
            d-&amp;gt;ht[0].used--;
            d-&amp;gt;ht[1].used++;
            de = nextde;
        }
        d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] = NULL;
        d-&amp;gt;rehashidx++;
    }
    
    /* Check if we already rehashed the whole table... */
    if (d-&amp;gt;ht[0].used == 0) {
        zfree(d-&amp;gt;ht[0].table);
        d-&amp;gt;ht[0] = d-&amp;gt;ht[1];
        _dictReset(&amp;amp;d-&amp;gt;ht[1]);
        d-&amp;gt;rehashidx = -1;
        return 0;
    }
    
    /* More to rehash... */
    return 1;
}
static void _dictRehashStep(dict *d) {
    if (d-&amp;gt;iterators == 0)
        dictRehash(d, 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;迭代器&lt;/h3&gt;

&lt;p&gt;迭代器有一个特性：　迭代过程中，当前指针不能被删除。&lt;br /&gt;
所有实现迭代器的时候，　有必要在迭代的时候禁止修改或者修改的时候能够感知到。&lt;/p&gt;

&lt;p&gt;这里支持两种模式：　安全模式(禁止修改)，　监控模式(安全检查)。&lt;br /&gt;
安全模式很好理解，　有一个开关，修改的时候判断即可。&lt;br /&gt;
监控模式就需要好好选择一个方法了，　选择的不好时很影响性能的，　下个小节可以看看&lt;code class=&quot;highlighter-rouge&quot;&gt;dictFingerprint&lt;/code&gt;的实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dictEntry *dictNext(dictIterator *iter) {
    while (1) {
        if (iter-&amp;gt;entry == NULL) {
            dictht *ht = &amp;amp;iter-&amp;gt;d-&amp;gt;ht[iter-&amp;gt;table];
            if (iter-&amp;gt;index == -1 &amp;amp;&amp;amp; iter-&amp;gt;table == 0) {
                if (iter-&amp;gt;safe)
                    iter-&amp;gt;d-&amp;gt;iterators++;
                else
                    iter-&amp;gt;fingerprint = dictFingerprint(iter-&amp;gt;d);
            }
            iter-&amp;gt;index++;
            if (iter-&amp;gt;index &amp;gt;= (long) ht-&amp;gt;size) {
                if (dictIsRehashing(iter-&amp;gt;d) &amp;amp;&amp;amp; iter-&amp;gt;table == 0) {
                    iter-&amp;gt;table++;
                    iter-&amp;gt;index = 0;
                    ht = &amp;amp;iter-&amp;gt;d-&amp;gt;ht[1];
                } else {
                    break;
                }
            }
            iter-&amp;gt;entry = ht-&amp;gt;table[iter-&amp;gt;index];
        } else {
            iter-&amp;gt;entry = iter-&amp;gt;nextEntry;
        }
        if (iter-&amp;gt;entry) {
            /* We need to save the 'next' here, the iterator user
             * may delete the entry we are returning. */
            iter-&amp;gt;nextEntry = iter-&amp;gt;entry-&amp;gt;next;
            return iter-&amp;gt;entry;
        }
    }
    return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-9&quot;&gt;其他功能&lt;/h2&gt;

&lt;h3 id=&quot;section-10&quot;&gt;监控模式&lt;/h3&gt;

&lt;p&gt;迭代器中提到可以使用监控模式来检查迭代时，　数据是否被修改。&lt;/p&gt;

&lt;p&gt;这里的实现也很简单，　监控的指标有: 两个hash的指针，大小，使用个数。&lt;br /&gt;
指针和大小一旦改变，　很容易监控到，　但是个数这个数据，　就不能保证了。&lt;br /&gt;
比如增加一个元素，　删除一个元素，　个数是不变的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long long dictFingerprint(dict *d) {
    long long integers[6], hash = 0;
    int j;
    
    integers[0] = (long) d-&amp;gt;ht[0].table;
    integers[1] = d-&amp;gt;ht[0].size;
    integers[2] = d-&amp;gt;ht[0].used;
    integers[3] = (long) d-&amp;gt;ht[1].table;
    integers[4] = d-&amp;gt;ht[1].size;
    integers[5] = d-&amp;gt;ht[1].used;
    
    /* We hash N integers by summing every successive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result = hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in a different order will (likely) hash
     * to a different number. */
    for (j = 0; j &amp;lt; 6; j++) {
        hash += integers[j];
        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */
        hash = (~hash) + (hash &amp;lt;&amp;lt; 21); // hash = (hash &amp;lt;&amp;lt; 21) - hash - 1;
        hash = hash ^ (hash &amp;gt;&amp;gt; 24);
        hash = (hash + (hash &amp;lt;&amp;lt; 3)) + (hash &amp;lt;&amp;lt; 8); // hash * 265
        hash = hash ^ (hash &amp;gt;&amp;gt; 14);
        hash = (hash + (hash &amp;lt;&amp;lt; 2)) + (hash &amp;lt;&amp;lt; 4); // hash * 21
        hash = hash ^ (hash &amp;gt;&amp;gt; 28);
        hash = hash + (hash &amp;lt;&amp;lt; 31);
    }
    return hash;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;随机节点&lt;/h3&gt;

&lt;p&gt;假设我们的数据右上限，　当达到上限的时候，我们需要使用淘汰算法来删除数据。&lt;br /&gt;
一种最简单的方式就是随机找一个数据，删除。&lt;br /&gt;
字典表中提供了这样一个方法。&lt;/p&gt;

&lt;p&gt;算法也很简单：　第一步随机找到链表，　第二步在链表中随机找一个元素。&lt;br /&gt;
由于这里的hash可能有两个，　所以需要分两种情况来特殊判断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Return a random entry from the hash table. Useful to
 * implement randomized algorithms */
dictEntry *dictGetRandomKey(dict *d) {
    dictEntry *he, *orighe;
    unsigned int h;
    int listlen, listele;
    
    if (dictSize(d) == 0)
        return NULL;
    if (dictIsRehashing(d))
        _dictRehashStep(d);
    if (dictIsRehashing(d)) {
        do {
            /* We are sure there are no elements in indexes from 0
             * to rehashidx-1 */
            h =d-&amp;gt;rehashidx+ (random()% (d-&amp;gt;ht[0].size + d-&amp;gt;ht[1].size- d-&amp;gt;rehashidx));
            he = (h &amp;gt;= d-&amp;gt;ht[0].size) ? d-&amp;gt;ht[1].table[h - d-&amp;gt;ht[0].size] : d-&amp;gt;ht[0].table[h];
        } while (he == NULL);
    } else {
        do {
            h = random() &amp;amp; d-&amp;gt;ht[0].sizemask;
            he = d-&amp;gt;ht[0].table[h];
        } while (he == NULL);
    }
    
    /* Now we found a non empty bucket, but it is a linked
     * list and we need to get a random element from the list.
     * The only sane way to do so is counting the elements and
     * select a random index. */
    listlen = 0;
    orighe = he;
    while (he) {
        he = he-&amp;gt;next;
        listlen++;
    }
    listele = random() % listlen;
    he = orighe;
    while (listele--)
        he = he-&amp;gt;next;
    return he;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hash-1&quot;&gt;32位整数hash算法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Thomas Wang's 32 bit Mix Function */
unsigned int dictIntHashFunction(unsigned int key) {
    key += ~(key &amp;lt;&amp;lt; 15);
    key ^= (key &amp;gt;&amp;gt; 10);
    key += (key &amp;lt;&amp;lt; 3);
    key ^= (key &amp;gt;&amp;gt; 6);
    key += ~(key &amp;lt;&amp;lt; 11);
    key ^= (key &amp;gt;&amp;gt; 16);
    return key;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>redis源码阅读之双向列表</title>
     <link href="http://localhost:4000/blog/2016/04/04/redis-doubly-linked-list.html"/>
     <updated>2016-04-04T00:57:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/04/04/redis-doubly-linked-list</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;redis是一个很不错的NOSQL数据库。&lt;br /&gt;
关于redis的使用文档， 可以参考&lt;a href=&quot;/doc/redis/&quot;&gt;这里&lt;/a&gt;.&lt;br /&gt;
关于redis双向链表的源码可以参考&lt;a href=&quot;https://github.com/tiankonguse/redis/tree/unstable/src/comlib/adlist&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;功能&lt;/h2&gt;

&lt;p&gt;双向链表， 看名字就知道， 不单单记录着下一个元素的位置， 还记录着上一个元素的位置。&lt;br /&gt;
这里定义了三个基础结构：&lt;code class=&quot;highlighter-rouge&quot;&gt;listNode&lt;/code&gt;节点元素， &lt;code class=&quot;highlighter-rouge&quot;&gt;listIter&lt;/code&gt;迭代器， &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;列表容器， 所有操作都是在这个结构的基础上操作。&lt;br /&gt;
有点STL的思想。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基础结构确定后， 对应的基本操作也就确定了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listCreate&lt;/code&gt; 创建列表&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listRelease&lt;/code&gt; 释放列表&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listAddNodeHead&lt;/code&gt; 列表头部增加元素&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listAddNodeTail&lt;/code&gt; 列表尾部增加元素&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listInsertNode&lt;/code&gt; 指定位置增加元素(前或者后由参数决定)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listDelNode&lt;/code&gt; 删除元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一个容器， 迭代也需要具备一些基本功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listGetIterator&lt;/code&gt; 创建迭代器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listNext&lt;/code&gt; 迭代&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listReleaseIterator&lt;/code&gt; 释放迭代器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;redis还附加了一些功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listDup&lt;/code&gt; 复制列表&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listSearchKey&lt;/code&gt; 列表中搜索值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listIndex&lt;/code&gt; 表中指定位置的节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listRewind&lt;/code&gt; 迭代器重置到表头&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listRewindTail&lt;/code&gt; 迭代器重置到表尾&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listRotate&lt;/code&gt; 顺时针旋转指针一次（循环左移）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;基本操作&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;创建列表&lt;/h3&gt;

&lt;p&gt;申请内存， 初始化列表即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list *listCreate(void){
    struct list *list;
    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;
    list-&amp;gt;head = list-&amp;gt;tail = NULL;
    list-&amp;gt;len = 0;
    list-&amp;gt;dup = NULL;
    list-&amp;gt;free = NULL;
    list-&amp;gt;match = NULL;
    return list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;释放列表&lt;/h3&gt;

&lt;p&gt;先释放节点， 最后释放列表。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listRelease(list *list) {
    unsigned long len;
    listNode *current, *next;
    
    current = list-&amp;gt;head;
    len = list-&amp;gt;len;
    while (len--) {
        next = current-&amp;gt;next;
        if (list-&amp;gt;free)
            list-&amp;gt;free(current-&amp;gt;value);
        zfree(current);
        current = next;
    }
    zfree(list);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;列表头部增加元素&lt;/h3&gt;

&lt;p&gt;对于头部添加元素， 需要特殊考虑的就是是否已经有节点了。&lt;br /&gt;
又由于是双向列表， 所以需要旧的头部的&lt;code class=&quot;highlighter-rouge&quot;&gt;prev&lt;/code&gt;指向新的节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list *listAddNodeHead(list *list, void *value) {
    listNode *node;
    
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node-&amp;gt;value = value;
    if (list-&amp;gt;len == 0) {
        list-&amp;gt;head = list-&amp;gt;tail = node;
        node-&amp;gt;prev = node-&amp;gt;next = NULL;
    } else {
        node-&amp;gt;prev = NULL;
        node-&amp;gt;next = list-&amp;gt;head;
        list-&amp;gt;head-&amp;gt;prev = node;
        list-&amp;gt;head = node;
    }
    list-&amp;gt;len++;
    return list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;列表尾部增加元素&lt;/h3&gt;

&lt;p&gt;增加尾部节点和增加头部节点类似， 需要判断是否已经有节点了。&lt;br /&gt;
旧的尾部指向新的尾部。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list *listAddNodeTail(list *list, void *value) {
    listNode *node;
    
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node-&amp;gt;value = value;
    if (list-&amp;gt;len == 0) {
        list-&amp;gt;head = list-&amp;gt;tail = node;
        node-&amp;gt;prev = node-&amp;gt;next = NULL;
    } else {
        node-&amp;gt;prev = list-&amp;gt;tail;
        node-&amp;gt;next = NULL;
        list-&amp;gt;tail-&amp;gt;next = node;
        list-&amp;gt;tail = node;
    }
    list-&amp;gt;len++;
    return list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;### 指定位置增加元素&lt;/p&gt;

&lt;p&gt;由于是指定位置添加元素， 所以可以确定列表中已经有元素了。&lt;br /&gt;
所以可以先把新节点的&lt;code class=&quot;highlighter-rouge&quot;&gt;prev&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;确定了。&lt;br /&gt;
然后根据节点是否是头部，尾部来更新其他节点的指针和列表的指针。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;
    
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node-&amp;gt;value = value;
    if (after) {
        node-&amp;gt;prev = old_node;
        node-&amp;gt;next = old_node-&amp;gt;next;
        if (list-&amp;gt;tail == old_node) {
            list-&amp;gt;tail = node;
        }
    } else {
        node-&amp;gt;next = old_node;
        node-&amp;gt;prev = old_node-&amp;gt;prev;
        if (list-&amp;gt;head == old_node) {
            list-&amp;gt;head = node;
        }
    }
    if (node-&amp;gt;prev != NULL) {
        node-&amp;gt;prev-&amp;gt;next = node;
    }
    if (node-&amp;gt;next != NULL) {
        node-&amp;gt;next-&amp;gt;prev = node;
    }
    list-&amp;gt;len++;
    return list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;删除元素&lt;/h3&gt;

&lt;p&gt;处理好其他节点的指针和列表的指针即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listDelNode(list *list, listNode *node) {
    if (node-&amp;gt;prev)
        node-&amp;gt;prev-&amp;gt;next = node-&amp;gt;next;
    else
        list-&amp;gt;head = node-&amp;gt;next;
    if (node-&amp;gt;next)
        node-&amp;gt;next-&amp;gt;prev = node-&amp;gt;prev;
    else
        list-&amp;gt;tail = node-&amp;gt;prev;
    if (list-&amp;gt;free)
        list-&amp;gt;free(node-&amp;gt;value);
    zfree(node);
    list-&amp;gt;len--;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-8&quot;&gt;迭代器&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;创建迭代器&lt;/h3&gt;

&lt;p&gt;申请迭代器的内存， 确认是头部还是尾部即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listIter *listGetIterator(list *list, int direction) {
    listIter *iter;
    
    if ((iter = zmalloc(sizeof(*iter))) == NULL)
        return NULL;
    if (direction == AL_START_HEAD)
        iter-&amp;gt;next = list-&amp;gt;head;
    else
        iter-&amp;gt;next = list-&amp;gt;tail;
    iter-&amp;gt;direction = direction;
    return iter;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;迭代&lt;/h3&gt;

&lt;p&gt;根据方向， 移动带下一个节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listNode *listNext(listIter *iter) {
    listNode *current = iter-&amp;gt;next;
    
    if (current != NULL) {
        if (iter-&amp;gt;direction == AL_START_HEAD)
            iter-&amp;gt;next = current-&amp;gt;next;
        else
            iter-&amp;gt;next = current-&amp;gt;prev;
    }
    return current;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;释放迭代器&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listReleaseIterator(listIter *iter) {
    zfree(iter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-12&quot;&gt;附加功能&lt;/h2&gt;

&lt;h3 id=&quot;section-13&quot;&gt;复制列表&lt;/h3&gt;

&lt;p&gt;不知你是否还记得list结构里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;void *(*dup)(void *ptr);&lt;/code&gt;函数指针。&lt;br /&gt;
这个函数指针用于决定是否深拷贝列表， 如果要深拷贝列表， 需要指定深拷贝函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list *listDup(list *orig) {
    list *copy;
    listIter *iter;
    listNode *node;
    
    if ((copy = listCreate()) == NULL)
        return NULL;
    copy-&amp;gt;dup = orig-&amp;gt;dup;
    copy-&amp;gt;free = orig-&amp;gt;free;
    copy-&amp;gt;match = orig-&amp;gt;match;
    iter = listGetIterator(orig, AL_START_HEAD);
    while ((node = listNext(iter)) != NULL) {
        void *value;
        
        if (copy-&amp;gt;dup) {
            value = copy-&amp;gt;dup(node-&amp;gt;value);
            if (value == NULL) {
                listRelease(copy);
                listReleaseIterator(iter);
                return NULL;
            }
        } else
            value = node-&amp;gt;value;
        if (listAddNodeTail(copy, value) == NULL) {
            listRelease(copy);
            listReleaseIterator(iter);
            return NULL;
        }
    }
    listReleaseIterator(iter);
    return copy;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-14&quot;&gt;列表中搜索值&lt;/h3&gt;

&lt;p&gt;列表搜索的时候， 同样需要指定搜索函数&lt;code class=&quot;highlighter-rouge&quot;&gt;int (*match)(void *ptr, void *key);&lt;/code&gt;。&lt;br /&gt;
如果没指定搜索函数， 将会按指针比较来搜索了。&lt;br /&gt;
搜索复杂度&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listNode *listSearchKey(list *list, void *key) {
    listIter *iter;
    listNode *node;
    
    iter = listGetIterator(list, AL_START_HEAD);
    while ((node = listNext(iter)) != NULL) {
        if (list-&amp;gt;match) {
            if (list-&amp;gt;match(node-&amp;gt;value, key)) {
                listReleaseIterator(iter);
                return node;
            }
        } else {
            if (key == node-&amp;gt;value) {
                listReleaseIterator(iter);
                return node;
            }
        }
    }
    listReleaseIterator(iter);
    return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-15&quot;&gt;表中指定位置的节点&lt;/h3&gt;

&lt;p&gt;通过位置来获得节点的实现简单粗暴： 一个循环即可。&lt;br /&gt;
当位置是负数的时候， 就是从尾部逆序搜索了。&lt;br /&gt;
当位置大于列表的节点个数时， 肯定会返回空指针了。&lt;br /&gt;
实际上可以先判断一下位置， 这样对于大于列表节点个数的查询， 直接返回空指针。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listNode *listIndex(list *list, long index) {
    listNode *n;
    
    if (index &amp;lt; 0) {
        index = (-index) - 1;
        n = list-&amp;gt;tail;
        while (index-- &amp;amp;&amp;amp; n)
            n = n-&amp;gt;prev;
    } else {
        n = list-&amp;gt;head;
        while (index-- &amp;amp;&amp;amp; n)
            n = n-&amp;gt;next;
    }
    return n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-16&quot;&gt;迭代器置头置尾&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listRewind(list *list, listIter *li) {
    li-&amp;gt;next = list-&amp;gt;head;
    li-&amp;gt;direction = AL_START_HEAD;
}

void listRewindTail(list *list, listIter *li) {
    li-&amp;gt;next = list-&amp;gt;tail;
    li-&amp;gt;direction = AL_START_TAIL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-17&quot;&gt;顺时针旋转&lt;/h3&gt;

&lt;p&gt;实现方式很普通：保存尾节点， 列表的尾节点更新， 插入头节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listRotate(list *list) {
    listNode *tail = list-&amp;gt;tail;
    
    if (listLength(list) &amp;lt;= 1)
        return;
    
    /* Detach current tail */
    list-&amp;gt;tail = tail-&amp;gt;prev;
    list-&amp;gt;tail-&amp;gt;next = NULL;
    /* Move it as head */
    list-&amp;gt;head-&amp;gt;prev = tail;
    tail-&amp;gt;prev = NULL;
    tail-&amp;gt;next = list-&amp;gt;head;
    list-&amp;gt;head = tail;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际上可以更简单点。&lt;br /&gt;
当然， 下面的方法需要八条语句， 但是应该更好理解吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void listRotate(list *list) {
    
    if (listLength(list) &amp;lt;= 1)
        return;
    
    //节点首尾相连
    list-&amp;gt;tail-&amp;gt;next = list-&amp;gt;head;
    list-&amp;gt;head-&amp;gt;prev = list-&amp;gt;tail;
    
    //列表更新首尾
    list-&amp;gt;tail = list-&amp;gt;tail-&amp;gt;prev；
    list-&amp;gt;head = list-&amp;gt;head-&amp;gt;prev;
    
    //首尾节点反相连
    list-&amp;gt;tail-&amp;gt;next = NULL;
    list-&amp;gt;head-&amp;gt;prev = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
    
   <entry>
     <title>redis源码阅读</title>
     <link href="http://localhost:4000/blog/2016/04/03/redis.html"/>
     <updated>2016-04-03T23:01:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/04/03/redis</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;redis是一个很不错的NOSQL数据库。&lt;br /&gt;
关于redis的使用文档， 可以参考&lt;a href=&quot;/doc/redis/&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;记录集&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2016/04/03/redis-allocated-memory.html&quot;&gt;redis源码阅读之内存管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2016/04/03/redis-endinconv.html&quot;&gt;redis源码阅读之大小端转换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2016/04/04/redis-doubly-linked-list.html&quot;&gt;redis源码阅读之双向列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
    
   <entry>
     <title>redis源码阅读之大小端转换</title>
     <link href="http://localhost:4000/blog/2016/04/03/redis-endinconv.html"/>
     <updated>2016-04-03T22:51:00+08:00</updated>
     <id>http://localhost:4000/blog/2016/04/03/redis-endinconv</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;redis是一个很不错的NOSQL数据库。&lt;br /&gt;
关于redis的使用文档， 可以参考&lt;a href=&quot;/doc/redis/&quot;&gt;这里&lt;/a&gt;.&lt;br /&gt;
关于redis大小端转换的源码可以参考&lt;a href=&quot;https://github.com/tiankonguse/redis/tree/unstable/src/comlib/endinconv&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;功能&lt;/h2&gt;

&lt;p&gt;一般需要进行大小端转换的有&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;(16位), &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;(32位), &lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;(64位).&lt;br /&gt;
而下面这三个函数分别调用了对应的通用的转换函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint16_t intrev16(uint16_t v) {
    memrev16(&amp;amp;v);
    return v;
}

uint32_t intrev32(uint32_t v) {
    memrev32(&amp;amp;v);
    return v;
}

uint64_t intrev64(uint64_t v) {
    memrev64(&amp;amp;v);
    return v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;转换&lt;/h2&gt;

&lt;p&gt;由于要转换的只有三个尺寸， 所以直接交换即可。&lt;br /&gt;
显然， 交换算法写成函数或者宏更好了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void memrev16(void *p) {
    unsigned char *x = p, t;
    t = x[0];x[0] = x[1];x[1] = t;
}

void memrev32(void *p) {
    unsigned char *x = p, t;
    t = x[0];x[0] = x[3];x[3] = t;
    t = x[1];x[1] = x[2];x[2] = t;
}

void memrev64(void *p) {
    unsigned char *x = p, t;
    t = x[0];x[0] = x[7];x[7] = t;
    t = x[1];x[1] = x[6];x[6] = t;
    t = x[2];x[2] = x[5];x[5] = t;
    t = x[3];x[3] = x[4];x[4] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;写成宏后就会简单点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define SWAP(l, r, t) do{t = l;l = r;l = t;}while(0)

void memrev16(void *p) {
    unsigned char *x = p, t;
    SWAP(x[0], x[1], t);
}

void memrev32(void *p) {
    unsigned char *x = p, t;
    SWAP(x[0], x[3], t);
    SWAP(x[1], x[2], t);
}

void memrev64(void *p) {
    unsigned char *x = p, t;
    SWAP(x[0], x[7], t);
    SWAP(x[1], x[6], t);
    SWAP(x[2], x[5], t);
    SWAP(x[3], x[4], t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;虽然只有三个， 如果封装成通用的函数就更好了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define SWAP(l, r, t) do{t = l;l = r;l = t;}while(0)

void memrev(void *p, int size) {
    unsigned char *x = p, t;
    int l=0, r = size - 1;
    while(l &amp;lt; r){
        SWAP(x[l], x[r], t);
        l++,r--;
    }
}

void memrev16(void *p) {
    memrev(p, 2);
}

void memrev32(void *p) {
    memrev(p, 4);
}

void memrev64(void *p) {
    memrev(p, 8);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
   </entry>
   
 
</feed>
